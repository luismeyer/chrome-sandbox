module.exports = [
"[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/api-client/api-error.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.APIError = void 0;
class APIError extends Error {
    constructor(response, options){
        super(response.statusText);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, APIError);
        }
        this.response = response;
        this.message = options?.message ?? "";
        this.json = options?.json;
        this.text = options?.text;
    }
}
exports.APIError = APIError;
}),
"[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/utils/array.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.array = array;
/**
 * Returns an array from the given item. If the  item is an array it will be
 * returned as a it is, otherwise it will be returned as a single item array.
 * If the item is undefined or null an empty array will be returned.
 *
 * @param item The item to convert to an array.
 * @returns An array.
 */ function array(item) {
    return item !== undefined && item !== null ? Array.isArray(item) ? item : [
        item
    ] : [];
}
}),
"[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/api-client/with-retry.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.withRetry = withRetry;
const api_error_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/api-client/api-error.js [app-rsc] (ecmascript)");
const promises_1 = __turbopack_context__.r("[externals]/timers/promises [external] (timers/promises, cjs)");
const async_retry_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/async-retry@1.3.3/node_modules/async-retry/lib/index.js [app-rsc] (ecmascript)"));
/**
 * Wraps a fetch function with retry logic. The retry logic will retry
 * on network errors, 429 responses and 5xx responses. The retry logic
 * will not retry on 4xx responses.
 *
 * @param rawFetch The fetch function to wrap.
 * @returns The wrapped fetch function.
 */ function withRetry(rawFetch) {
    return async (url, opts = {})=>{
        /**
         * Timeouts by default will be [10, 60, 360, 2160, 12960]
         * before randomization is added.
         */ const retryOpts = Object.assign({
            minTimeout: 10,
            retries: 5,
            factor: 6,
            maxRetryAfter: 20
        }, opts.retry);
        if (opts.onRetry) {
            retryOpts.onRetry = (error, attempts)=>{
                opts.onRetry(error, opts);
                if (opts.retry && opts.retry.onRetry) {
                    opts.retry.onRetry(error, attempts);
                }
            };
        }
        try {
            return await (0, async_retry_1.default)(async (bail)=>{
                try {
                    const response = await rawFetch(url, opts);
                    /**
                     * When the response is 429 we will try to parse the Retry-After
                     * header. If the header exists we will try to parse it and, if
                     * the wait time is higher than the maximum defined, we respond.
                     * Otherwise we wait for the time given in the header and throw
                     * to retry.
                     */ if (response.status === 429) {
                        const retryAfter = parseInt(response.headers.get("retry-after") || "", 10);
                        if (retryAfter && !isNaN(retryAfter)) {
                            if (retryAfter > retryOpts.maxRetryAfter) {
                                return response;
                            }
                            await (0, promises_1.setTimeout)(retryAfter * 1e3);
                        }
                        throw new api_error_1.APIError(response);
                    }
                    /**
                     * If the response is a a retryable error, we throw in
                     * order to retry.
                     */ if (response.status >= 500 && response.status < 600) {
                        throw new api_error_1.APIError(response);
                    }
                    return response;
                } catch (error) {
                    /**
                     * If the request was aborted using the AbortController
                     * we bail from retrying throwing the original error.
                     */ if (isAbortError(error)) {
                        return bail(error);
                    }
                    throw error;
                }
            }, retryOpts);
        } catch (error) {
            /**
             * The ResponseError is only intended for retries so in case we
             * ran out of attempts we will respond with the last response
             * we obtained.
             */ if (error instanceof api_error_1.APIError) {
                return error.response;
            }
            throw error;
        }
    };
}
function isAbortError(error) {
    return error !== undefined && error !== null && error.name === "AbortError";
}
}),
"[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/api-client/base-client.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BaseClient = void 0;
exports.parse = parse;
exports.parseOrThrow = parseOrThrow;
const api_error_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/api-client/api-error.js [app-rsc] (ecmascript)");
const array_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/utils/array.js [app-rsc] (ecmascript)");
const with_retry_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/api-client/with-retry.js [app-rsc] (ecmascript)");
const undici_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/undici@7.16.0/node_modules/undici/index.js [app-rsc] (ecmascript)");
/**
 * A base API client that provides a convenience wrapper for fetching where
 * we can pass query parameters as an object, support retries, debugging
 * and automatic authorization.
 */ class BaseClient {
    constructor(params){
        this.fetch = (0, with_retry_1.withRetry)(globalThis.fetch);
        this.host = params.host;
        this.debug = params.debug ?? process.env.DEBUG_FETCH === "true";
        this.token = params.token;
        this.agent = new undici_1.Agent({
            bodyTimeout: 0
        });
    }
    async request(path, opts) {
        const url = new URL(path, this.host);
        if (opts?.query) {
            for (const [key, value] of Object.entries(opts.query)){
                (0, array_1.array)(value).forEach((value)=>{
                    url.searchParams.append(key, value.toString());
                });
            }
        }
        const start = Date.now();
        const response = await this.fetch(url.toString(), {
            ...opts,
            body: opts?.body,
            method: opts?.method || "GET",
            headers: this.token ? {
                Authorization: `Bearer ${this.token}`,
                ...opts?.headers
            } : opts?.headers,
            // @ts-expect-error Node.js' and undici's Agent have different types
            dispatcher: this.agent
        });
        if (this.debug) {
            const duration = Date.now() - start;
            console.log(`[API] ${url} (${response.status}) ${duration}ms`);
            if (response.status === 429) {
                const retry = parseInt(response.headers.get("Retry-After") ?? "", 10);
                const hours = Math.floor(retry / 60 / 60);
                const minutes = Math.floor(retry / 60) % 60;
                const seconds = retry % 60;
                console.warn(`[API] ${url} Rate Limited, Retry After ${hours}h ${minutes}m ${seconds}s`);
            }
        }
        return response;
    }
}
exports.BaseClient = BaseClient;
/**
 * Allows to read the response text and parse it as JSON casting to the given
 * type. If the response is not ok or cannot be parsed it will return error.
 *
 * @param response Response to parse.
 * @returns Parsed response or error.
 */ async function parse(validator, response) {
    const text = await response.text().catch((err)=>{
        return new api_error_1.APIError(response, {
            message: `Can't read response text: ${String(err)}`
        });
    });
    if (typeof text !== "string") {
        return text;
    }
    let json;
    try {
        json = JSON.parse(text || "{}");
    } catch (error) {
        return new api_error_1.APIError(response, {
            message: `Can't parse JSON: ${String(error)}`,
            text
        });
    }
    if (!response.ok) {
        return new api_error_1.APIError(response, {
            message: `Status code ${response.status} is not ok`,
            json: json,
            text
        });
    }
    const validated = validator.safeParse(json);
    if (!validated.success) {
        return new api_error_1.APIError(response, {
            message: `Response JSON is not valid: ${validated.error}`,
            json: json,
            text
        });
    }
    return {
        json: validated.data,
        response,
        text
    };
}
async function parseOrThrow(validator, response) {
    const result = await parse(validator, response);
    if (result instanceof api_error_1.APIError) {
        throw result;
    }
    return result;
}
}),
"[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/api-client/validators.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SandboxesResponse = exports.LogLine = exports.EmptyResponse = exports.CommandFinishedResponse = exports.CommandResponse = exports.SandboxAndRoutesResponse = exports.SandboxResponse = exports.Command = exports.Pagination = exports.SandboxRoute = exports.Sandbox = void 0;
const zod_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/zod@3.24.4/node_modules/zod/lib/index.js [app-rsc] (ecmascript)");
exports.Sandbox = zod_1.z.object({
    id: zod_1.z.string(),
    memory: zod_1.z.number(),
    vcpus: zod_1.z.number(),
    region: zod_1.z.string(),
    runtime: zod_1.z.string(),
    timeout: zod_1.z.number(),
    status: zod_1.z.enum([
        "pending",
        "running",
        "stopping",
        "stopped",
        "failed"
    ]),
    requestedAt: zod_1.z.number(),
    startedAt: zod_1.z.number().optional(),
    requestedStopAt: zod_1.z.number().optional(),
    stoppedAt: zod_1.z.number().optional(),
    duration: zod_1.z.number().optional(),
    createdAt: zod_1.z.number(),
    cwd: zod_1.z.string(),
    updatedAt: zod_1.z.number()
});
exports.SandboxRoute = zod_1.z.object({
    url: zod_1.z.string(),
    subdomain: zod_1.z.string(),
    port: zod_1.z.number()
});
exports.Pagination = zod_1.z.object({
    /**
     * Amount of items in the current page.
     * @example 20
     */ count: zod_1.z.number(),
    /**
     * Timestamp that must be used to request the next page.
     * @example 1540095775951
     */ next: zod_1.z.number().nullable(),
    /**
     * Timestamp that must be used to request the previous page.
     * @example 1540095775951
     */ prev: zod_1.z.number().nullable()
});
exports.Command = zod_1.z.object({
    id: zod_1.z.string(),
    name: zod_1.z.string(),
    args: zod_1.z.array(zod_1.z.string()),
    cwd: zod_1.z.string(),
    sandboxId: zod_1.z.string(),
    exitCode: zod_1.z.number().nullable(),
    startedAt: zod_1.z.number()
});
const CommandFinished = exports.Command.extend({
    exitCode: zod_1.z.number()
});
exports.SandboxResponse = zod_1.z.object({
    sandbox: exports.Sandbox
});
exports.SandboxAndRoutesResponse = exports.SandboxResponse.extend({
    routes: zod_1.z.array(exports.SandboxRoute)
});
exports.CommandResponse = zod_1.z.object({
    command: exports.Command
});
exports.CommandFinishedResponse = zod_1.z.object({
    command: CommandFinished
});
exports.EmptyResponse = zod_1.z.object({});
exports.LogLine = zod_1.z.object({
    stream: zod_1.z.enum([
        "stdout",
        "stderr"
    ]),
    data: zod_1.z.string()
});
exports.SandboxesResponse = zod_1.z.object({
    sandboxes: zod_1.z.array(exports.Sandbox),
    pagination: exports.Pagination
});
}),
"[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/api-client/file-writer.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FileWriter = void 0;
const zlib_1 = __importDefault(__turbopack_context__.r("[externals]/zlib [external] (zlib, cjs)"));
const tar_stream_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/tar-stream@3.1.7/node_modules/tar-stream/index.js [app-rsc] (ecmascript)"));
const stream_1 = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
/**
 * Allows to create a Readable stream with methods to write files
 * to it and to finish it. Files written are compressed together
 * and gzipped in the stream.
 */ class FileWriter {
    constructor(){
        const gzip = zlib_1.default.createGzip();
        this.pack = tar_stream_1.default.pack();
        this.readable = this.pack.pipe(gzip);
    }
    /**
     * Allows to add a file to the stream. Size is required to write
     * the tarball header so when content is a stream it must be
     * provided.
     *
     * Returns a Promise resolved once the file is written in the
     * stream.
     */ async addFile(file) {
        return new Promise((resolve, reject)=>{
            const entry = this.pack.entry("size" in file ? {
                name: file.name,
                size: file.size
            } : {
                name: file.name,
                size: file.content.length
            }, (error)=>{
                if (error) {
                    return reject(error);
                } else {
                    resolve();
                }
            });
            if (file.content instanceof stream_1.Readable) {
                file.content.pipe(entry);
            } else {
                entry.end(file.content);
            }
        });
    }
    /**
     * Allows to finish the stream returning a Promise that will
     * resolve once the readable is effectively closed or
     * errored.
     */ async end() {
        return new Promise((resolve, reject)=>{
            this.readable.on("error", reject);
            this.readable.on("end", resolve);
            this.pack.finalize();
        });
    }
}
exports.FileWriter = FileWriter;
}),
"[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/version.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.VERSION = void 0;
// Autogenerated by inject-version.ts
exports.VERSION = "0.0.21";
}),
"[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/utils/consume-readable.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.consumeReadable = consumeReadable;
/**
 * Consumes a readable entirely concatenating all content in a single Buffer
 * @param readable A Readable stream
 */ function consumeReadable(readable) {
    return new Promise((resolve, reject)=>{
        const chunks = [];
        readable.on("error", (err)=>reject(err));
        readable.on("data", (chunk)=>chunks.push(chunk));
        readable.on("end", ()=>resolve(Buffer.concat(chunks)));
    });
}
}),
"[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/utils/normalizePath.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.normalizePath = normalizePath;
const path_1 = __importDefault(__turbopack_context__.r("[externals]/path [external] (path, cjs)"));
/**
 * Normalize a path and make it relative to `params.extractDir` for inclusion
 * in our tar archives.
 *
 * Relative paths are first resolved to `params.cwd`.
 * Absolute paths are normalized and resolved relative to `params.extractDir`.
 *
 * In addition, paths are normalized so consecutive slashes are removed and
 * stuff like `../..` is resolved appropriately.
 *
 * This function always returns a path relative to `params.extractDir`.
 */ function normalizePath(params) {
    if (!path_1.default.posix.isAbsolute(params.cwd)) {
        throw new Error("cwd dir must be absolute");
    }
    if (!path_1.default.posix.isAbsolute(params.extractDir)) {
        throw new Error("extractDir must be absolute");
    }
    const basePath = path_1.default.posix.isAbsolute(params.filePath) ? path_1.default.posix.normalize(params.filePath) : path_1.default.posix.join(params.cwd, params.filePath);
    return path_1.default.posix.relative(params.extractDir, basePath);
}
}),
"[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/utils/decode-base64-url.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decodeBase64Url = decodeBase64Url;
/**
 * Decode a Base64 URL-encoded string into a JSON object.
 *
 * @param base64Url - The Base64 URL-encoded string to decode.
 * @returns The decoded JSON object or null if decoding fails.
 */ function decodeBase64Url(base64Url) {
    return JSON.parse(Buffer.from(base64Url.replace(/-/g, "+").replace(/_/g, "/"), "base64").toString("utf8"));
}
}),
"[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/utils/get-credentials.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.schema = void 0;
exports.getCredentials = getCredentials;
const oidc_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+oidc@2.0.2/node_modules/@vercel/oidc/dist/index.js [app-rsc] (ecmascript)");
const decode_base64_url_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/utils/decode-base64-url.js [app-rsc] (ecmascript)");
const zod_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/zod@3.24.4/node_modules/zod/lib/index.js [app-rsc] (ecmascript)");
/**
 * Allow to get credentials to access the Vercel API. Credentials can be
 * provided in two different ways:
 *
 * 1. By passing an object with the `teamId`, `token`, and `projectId` properties.
 * 2. By using an environment variable VERCEL_OIDC_TOKEN.
 *
 * If both methods are used, the object properties take precedence over the
 * environment variable. If neither method is used, an error is thrown.
 */ async function getCredentials(params) {
    const credentials = getCredentialsFromParams(params ?? {});
    if (credentials) {
        return credentials;
    }
    const oidcToken = await (0, oidc_1.getVercelOidcToken)();
    if (oidcToken) {
        return getCredentialsFromOIDCToken(oidcToken);
    }
    throw new Error("You must provide credentials to access the Vercel API \n" + "either through parameters or using OpenID Connect [https://vercel.com/docs/oidc]");
}
/**
 * Attempt to extract credentials from the provided parameters. Either all
 * required fields (`token`, `teamId`, and `projectId`) must be present
 * or none of them, otherwise an error is thrown.
 */ function getCredentialsFromParams(params) {
    // Type guard: params must be an object
    if (!params || typeof params !== "object") {
        return null;
    }
    const missing = [
        "token" in params && typeof params.token === "string" ? null : "token",
        "teamId" in params && typeof params.teamId === "string" ? null : "teamId",
        "projectId" in params && typeof params.projectId === "string" ? null : "projectId"
    ].filter((value)=>value !== null);
    if (missing.length === 0) {
        return {
            token: params.token,
            projectId: params.projectId,
            teamId: params.teamId
        };
    }
    if (missing.length < 3) {
        throw new Error(`Missing credentials parameters to access the Vercel API: ${missing.filter((value)=>value !== null).join(", ")}`);
    }
    return null;
}
/**
 * Schema to validate the payload of the Vercel OIDC token where we expect
 * to find the `teamId` and `projectId`.
 */ exports.schema = zod_1.z.object({
    exp: zod_1.z.number().optional().describe("Expiry timestamp (seconds since epoch)"),
    iat: zod_1.z.number().optional().describe("Issued at timestamp"),
    owner_id: zod_1.z.string(),
    project_id: zod_1.z.string()
});
/**
 * Extracts credentials from a Vercel OIDC token. The token is expected to be
 * a JWT with a payload that contains `project_id` and `owner_id`.
 *
 * @param token - The Vercel OIDC token.
 * @returns An object containing the token, projectId, and teamId.
 * @throws If the token is invalid or does not contain the required fields.
 */ function getCredentialsFromOIDCToken(token) {
    try {
        const payload = exports.schema.parse((0, decode_base64_url_1.decodeBase64Url)(token.split(".")[1]));
        return {
            token,
            projectId: payload.project_id,
            teamId: payload.owner_id
        };
    } catch (error) {
        throw new Error(`Invalid Vercel OIDC token: ${error instanceof Error ? error.message : String(error)}`);
    }
}
}),
"[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/utils/jwt-expiry.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.JwtExpiry = exports.OidcRefreshError = void 0;
const decode_base64_url_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/utils/decode-base64-url.js [app-rsc] (ecmascript)");
const get_credentials_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/utils/get-credentials.js [app-rsc] (ecmascript)");
const oidc_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+oidc@2.0.2/node_modules/@vercel/oidc/dist/index.js [app-rsc] (ecmascript)");
const ms_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js [app-rsc] (ecmascript)"));
/** Time buffer before token expiry to consider it invalid (in milliseconds) */ const BUFFER_MS = (0, ms_1.default)("5m");
class OidcRefreshError extends Error {
    constructor(){
        super(...arguments);
        this.name = "OidcRefreshError";
    }
}
exports.OidcRefreshError = OidcRefreshError;
/**
 * Expiry implementation for JWT tokens (OIDC tokens).
 * Parses the JWT once and provides fast expiry validation.
 */ class JwtExpiry {
    static fromToken(token) {
        if (!isJwtFormat(token)) {
            return null;
        } else {
            return new JwtExpiry(token);
        }
    }
    /**
     * Creates a new JWT expiry checker.
     *
     * @param token - The JWT token to parse
     */ constructor(token){
        this.token = token;
        try {
            const tokenContents = token.split(".")[1];
            this.payload = get_credentials_1.schema.parse((0, decode_base64_url_1.decodeBase64Url)(tokenContents));
            this.expiryTime = this.payload.exp || null;
        } catch  {
            // Malformed token - treat as expired to trigger refresh
            this.expiryTime = 0;
        }
    }
    /**
     * Checks if the JWT token is valid (not expired).
     * @returns true if token is valid, false if expired or expiring soon
     */ isValid() {
        if (this.expiryTime === null) {
            return false; // No expiry means malformed JWT
        }
        const now = Math.floor(Date.now() / 1000);
        const buffer = BUFFER_MS / 1000;
        return now + buffer < this.expiryTime;
    }
    /**
     * Gets the expiry date of the JWT token.
     *
     * @returns Date object representing when the token expires, or null if no expiry
     */ getExpiryDate() {
        return this.expiryTime ? new Date(this.expiryTime * 1000) : null;
    }
    /**
     * Refreshes the JWT token by fetching a new OIDC token.
     *
     * @returns Promise resolving to a new JwtExpiry instance with fresh token
     */ async refresh() {
        try {
            const freshToken = await (0, oidc_1.getVercelOidcToken)();
            return new JwtExpiry(freshToken);
        } catch (cause) {
            throw new OidcRefreshError("Failed to refresh OIDC token", {
                cause
            });
        }
    }
    /**
     * Refreshes the JWT token if it's expired or expiring soon.
     */ async tryRefresh() {
        if (this.isValid()) {
            return null; // Still valid, no need to refresh
        }
        return this.refresh();
    }
}
exports.JwtExpiry = JwtExpiry;
/**
 * Checks if a token follows JWT format (has 3 parts separated by dots).
 *
 * @param token - The token to check
 * @returns true if token appears to be a JWT, false otherwise
 */ function isJwtFormat(token) {
    return token.split(".").length === 3;
}
}),
"[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/utils/types.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getPrivateParams = void 0;
/**
 * Extract private parameters out of an object.
 */ const getPrivateParams = (params)=>{
    const privateEntries = Object.entries(params ?? {}).filter(([k])=>k.startsWith("__"));
    return Object.fromEntries(privateEntries);
};
exports.getPrivateParams = getPrivateParams;
}),
"[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/api-client/api-client.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.APIClient = void 0;
const base_client_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/api-client/base-client.js [app-rsc] (ecmascript)");
const validators_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/api-client/validators.js [app-rsc] (ecmascript)");
const api_error_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/api-client/api-error.js [app-rsc] (ecmascript)");
const file_writer_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/api-client/file-writer.js [app-rsc] (ecmascript)");
const version_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/version.js [app-rsc] (ecmascript)");
const consume_readable_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/utils/consume-readable.js [app-rsc] (ecmascript)");
const jsonlines_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/.pnpm/jsonlines@0.1.1/node_modules/jsonlines/index.js [app-rsc] (ecmascript)"));
const os_1 = __importDefault(__turbopack_context__.r("[externals]/os [external] (os, cjs)"));
const stream_1 = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const normalizePath_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/utils/normalizePath.js [app-rsc] (ecmascript)");
const jwt_expiry_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/utils/jwt-expiry.js [app-rsc] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/utils/types.js [app-rsc] (ecmascript)");
class APIClient extends base_client_1.BaseClient {
    constructor(params){
        super({
            host: params.host ?? "https://api.vercel.com",
            token: params.token,
            debug: false
        });
        this.teamId = params.teamId;
        this.tokenExpiry = jwt_expiry_1.JwtExpiry.fromToken(params.token);
    }
    async ensureValidToken() {
        if (!this.tokenExpiry) {
            return;
        }
        const newExpiry = await this.tokenExpiry.tryRefresh();
        if (!newExpiry) {
            return;
        }
        this.tokenExpiry = newExpiry;
        this.token = this.tokenExpiry.token;
        if (this.tokenExpiry.payload) {
            this.teamId = this.tokenExpiry.payload?.owner_id;
        }
    }
    async request(path, params) {
        await this.ensureValidToken();
        return super.request(path, {
            ...params,
            query: {
                teamId: this.teamId,
                ...params?.query
            },
            headers: {
                "content-type": "application/json",
                "user-agent": `vercel/sandbox/${version_1.VERSION} (Node.js/${process.version}; ${os_1.default.platform()}/${os_1.default.arch()})`,
                ...params?.headers
            }
        });
    }
    async getSandbox(params) {
        return (0, base_client_1.parseOrThrow)(validators_1.SandboxAndRoutesResponse, await this.request(`/v1/sandboxes/${params.sandboxId}`));
    }
    async createSandbox(params) {
        const privateParams = (0, types_1.getPrivateParams)(params);
        return (0, base_client_1.parseOrThrow)(validators_1.SandboxAndRoutesResponse, await this.request("/v1/sandboxes", {
            method: "POST",
            body: JSON.stringify({
                projectId: params.projectId,
                ports: params.ports,
                source: params.source,
                timeout: params.timeout,
                resources: params.resources,
                runtime: params.runtime,
                ...privateParams
            })
        }));
    }
    async runCommand(params) {
        return (0, base_client_1.parseOrThrow)(validators_1.CommandResponse, await this.request(`/v1/sandboxes/${params.sandboxId}/cmd`, {
            method: "POST",
            body: JSON.stringify({
                command: params.command,
                args: params.args,
                cwd: params.cwd,
                env: params.env,
                sudo: params.sudo
            })
        }));
    }
    async getCommand(params) {
        return params.wait ? (0, base_client_1.parseOrThrow)(validators_1.CommandFinishedResponse, await this.request(`/v1/sandboxes/${params.sandboxId}/cmd/${params.cmdId}`, {
            query: {
                wait: "true"
            }
        })) : (0, base_client_1.parseOrThrow)(validators_1.CommandResponse, await this.request(`/v1/sandboxes/${params.sandboxId}/cmd/${params.cmdId}`));
    }
    async mkDir(params) {
        return (0, base_client_1.parseOrThrow)(validators_1.EmptyResponse, await this.request(`/v1/sandboxes/${params.sandboxId}/fs/mkdir`, {
            method: "POST",
            body: JSON.stringify({
                path: params.path,
                cwd: params.cwd
            })
        }));
    }
    getFileWriter(params) {
        const writer = new file_writer_1.FileWriter();
        return {
            response: (async ()=>{
                return this.request(`/v1/sandboxes/${params.sandboxId}/fs/write`, {
                    method: "POST",
                    headers: {
                        "content-type": "application/gzip",
                        "x-cwd": params.extractDir
                    },
                    body: await (0, consume_readable_1.consumeReadable)(writer.readable)
                });
            })(),
            writer
        };
    }
    async listSandboxes(params) {
        return (0, base_client_1.parseOrThrow)(validators_1.SandboxesResponse, await this.request(`/v1/sandboxes`, {
            query: {
                project: params.projectId,
                limit: params.limit,
                since: typeof params.since === "number" ? params.since : params.since?.getTime(),
                until: typeof params.until === "number" ? params.until : params.until?.getTime()
            },
            method: "GET"
        }));
    }
    async writeFiles(params) {
        const { writer, response } = this.getFileWriter({
            sandboxId: params.sandboxId,
            extractDir: params.extractDir
        });
        for (const file of params.files){
            await writer.addFile({
                name: (0, normalizePath_1.normalizePath)({
                    filePath: file.path,
                    extractDir: params.extractDir,
                    cwd: params.cwd
                }),
                content: file.content
            });
        }
        writer.end();
        await (0, base_client_1.parseOrThrow)(validators_1.EmptyResponse, await response);
    }
    async readFile(params) {
        const response = await this.request(`/v1/sandboxes/${params.sandboxId}/fs/read`, {
            method: "POST",
            body: JSON.stringify({
                path: params.path,
                cwd: params.cwd
            })
        });
        if (response.status === 404) {
            return null;
        }
        if (response.body === null) {
            return null;
        }
        return stream_1.Readable.fromWeb(response.body);
    }
    async killCommand(params) {
        return (0, base_client_1.parseOrThrow)(validators_1.CommandResponse, await this.request(`/v1/sandboxes/${params.sandboxId}/${params.commandId}/kill`, {
            method: "POST",
            body: JSON.stringify({
                signal: params.signal
            })
        }));
    }
    getLogs(params) {
        const self = this;
        const disposer = new AbortController();
        const signal = !params.signal ? disposer.signal : mergeSignals(params.signal, disposer.signal);
        const generator = async function*() {
            const url = `/v1/sandboxes/${params.sandboxId}/cmd/${params.cmdId}/logs`;
            const response = await self.request(url, {
                method: "GET",
                signal
            });
            if (response.headers.get("content-type") !== "application/x-ndjson") {
                throw new api_error_1.APIError(response, {
                    message: "Expected a stream of logs"
                });
            }
            if (response.body === null) {
                throw new api_error_1.APIError(response, {
                    message: "No response body"
                });
            }
            const jsonlinesStream = jsonlines_1.default.parse();
            pipe(response.body, jsonlinesStream).catch((err)=>{
                console.error("Error piping logs:", err);
            });
            for await (const chunk of jsonlinesStream){
                yield validators_1.LogLine.parse(chunk);
            }
        }();
        return Object.assign(generator, {
            [Symbol.dispose] () {
                disposer.abort("Disposed");
            },
            close: ()=>disposer.abort("Disposed")
        });
    }
    async stopSandbox(params) {
        const url = `/v1/sandboxes/${params.sandboxId}/stop`;
        return (0, base_client_1.parseOrThrow)(validators_1.SandboxResponse, await this.request(url, {
            method: "POST"
        }));
    }
}
exports.APIClient = APIClient;
async function pipe(readable, output) {
    const reader = readable.getReader();
    try {
        while(true){
            const read = await reader.read();
            if (read.value) {
                output.write(Buffer.from(read.value));
            }
            if (read.done) {
                break;
            }
        }
    } catch (err) {
        output.emit("error", err);
    } finally{
        output.end();
    }
}
function mergeSignals(...signals) {
    const controller = new AbortController();
    const onAbort = ()=>{
        controller.abort();
        for (const signal of signals){
            signal.removeEventListener("abort", onAbort);
        }
    };
    for (const signal of signals){
        if (signal.aborted) {
            controller.abort();
            break;
        }
        signal.addEventListener("abort", onAbort);
    }
    return controller.signal;
}
}),
"[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/api-client/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.APIClient = void 0;
var api_client_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/api-client/api-client.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "APIClient", {
    enumerable: true,
    get: function() {
        return api_client_1.APIClient;
    }
});
__exportStar(__turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/api-client/validators.js [app-rsc] (ecmascript)"), exports);
}),
"[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/utils/resolveSignal.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.resolveSignal = resolveSignal;
const linuxSignalMapping = {
    SIGHUP: 1,
    SIGINT: 2,
    SIGQUIT: 3,
    SIGKILL: 9,
    SIGTERM: 15,
    SIGCONT: 18,
    SIGSTOP: 19
};
function resolveSignal(signal) {
    if (typeof signal === "number") {
        return signal;
    }
    if (signal in linuxSignalMapping) {
        return linuxSignalMapping[signal];
    }
    throw new Error(`Unknown signal name: ${String(signal)}`);
}
}),
"[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/command.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CommandFinished = exports.Command = void 0;
const resolveSignal_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/utils/resolveSignal.js [app-rsc] (ecmascript)");
/**
 * A command executed in a Sandbox.
 *
 * For detached commands, you can {@link wait} to get a {@link CommandFinished} instance
 * with the populated exit code. For non-detached commands, {@link Sandbox.runCommand}
 * automatically waits and returns a {@link CommandFinished} instance.
 *
 * You can iterate over command output with {@link logs}.
 *
 * @see {@link Sandbox.runCommand} to start a command.
 *
 * @hideconstructor
 */ class Command {
    /**
     * ID of the command execution.
     */ get cmdId() {
        return this.cmd.id;
    }
    get cwd() {
        return this.cmd.cwd;
    }
    get startedAt() {
        return this.cmd.startedAt;
    }
    /**
     * @param params - Object containing the client, sandbox ID, and command ID.
     * @param params.client - API client used to interact with the backend.
     * @param params.sandboxId - The ID of the sandbox where the command is running.
     * @param params.cmdId - The ID of the command execution.
     */ constructor({ client, sandboxId, cmd }){
        this.client = client;
        this.sandboxId = sandboxId;
        this.cmd = cmd;
        this.exitCode = cmd.exitCode ?? null;
    }
    /**
     * Iterate over the output of this command.
     *
     * ```
     * for await (const log of cmd.logs()) {
     *   if (log.stream === "stdout") {
     *     process.stdout.write(log.data);
     *   } else {
     *     process.stderr.write(log.data);
     *   }
     * }
     * ```
     *
     * @param opts - Optional parameters.
     * @param opts.signal - An AbortSignal to cancel log streaming.
     * @returns An async iterable of log entries from the command output.
     *
     * @see {@link Command.stdout}, {@link Command.stderr}, and {@link Command.output}
     * to access output as a string.
     */ logs(opts) {
        return this.client.getLogs({
            sandboxId: this.sandboxId,
            cmdId: this.cmd.id,
            signal: opts?.signal
        });
    }
    /**
     * Wait for a command to exit and populate its exit code.
     *
     * This method is useful for detached commands where you need to wait
     * for completion. For non-detached commands, {@link Sandbox.runCommand}
     * automatically waits and returns a {@link CommandFinished} instance.
     *
     * ```
     * const detachedCmd = await sandbox.runCommand({ cmd: 'sleep', args: ['5'], detached: true });
     * const result = await detachedCmd.wait();
     * if (result.exitCode !== 0) {
     *   console.error("Something went wrong...")
     * }
     * ```
     *
     * @returns A {@link CommandFinished} instance with populated exit code.
     */ async wait() {
        const command = await this.client.getCommand({
            sandboxId: this.sandboxId,
            cmdId: this.cmd.id,
            wait: true
        });
        return new CommandFinished({
            client: this.client,
            sandboxId: this.sandboxId,
            cmd: command.json.command,
            exitCode: command.json.command.exitCode
        });
    }
    /**
     * Get the output of `stdout`, `stderr`, or both as a string.
     *
     * NOTE: This may throw string conversion errors if the command does
     * not output valid Unicode.
     *
     * @param stream - The output stream to read: "stdout", "stderr", or "both".
     * @returns The output of the specified stream(s) as a string.
     */ async output(stream = "both") {
        let data = "";
        for await (const log of this.logs()){
            if (stream === "both" || log.stream === stream) {
                data += log.data;
            }
        }
        return data;
    }
    /**
     * Get the output of `stdout` as a string.
     *
     * NOTE: This may throw string conversion errors if the command does
     * not output valid Unicode.
     *
     * @returns The standard output of the command.
     */ async stdout() {
        return this.output("stdout");
    }
    /**
     * Get the output of `stderr` as a string.
     *
     * NOTE: This may throw string conversion errors if the command does
     * not output valid Unicode.
     *
     * @returns The standard error output of the command.
     */ async stderr() {
        return this.output("stderr");
    }
    /**
     * Kill a running command in a sandbox.
     *
     * @param params - commandId and the signal to send the running process.
     * Defaults to SIGTERM.
     * @returns Promise<void>.
     */ async kill(signal) {
        await this.client.killCommand({
            sandboxId: this.sandboxId,
            commandId: this.cmd.id,
            signal: (0, resolveSignal_1.resolveSignal)(signal ?? "SIGTERM")
        });
    }
}
exports.Command = Command;
/**
 * A command that has finished executing.
 *
 * The exit code is immediately available and populated upon creation.
 * Unlike {@link Command}, you don't need to call wait() - the command
 * has already completed execution.
 *
 * @hideconstructor
 */ class CommandFinished extends Command {
    /**
     * @param params - Object containing client, sandbox ID, command ID, and exit code.
     * @param params.client - API client used to interact with the backend.
     * @param params.sandboxId - The ID of the sandbox where the command ran.
     * @param params.cmdId - The ID of the command execution.
     * @param params.exitCode - The exit code of the completed command.
     */ constructor(params){
        super({
            ...params
        });
        this.exitCode = params.exitCode;
    }
    /**
     * The wait method is not needed for CommandFinished instances since
     * the command has already completed and exitCode is populated.
     *
     * @deprecated This method is redundant for CommandFinished instances.
     * The exitCode is already available.
     * @returns This CommandFinished instance.
     */ async wait() {
        return this;
    }
}
exports.CommandFinished = CommandFinished;
}),
"[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/sandbox.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Sandbox = void 0;
const api_client_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/api-client/index.js [app-rsc] (ecmascript)");
const command_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/command.js [app-rsc] (ecmascript)");
const get_credentials_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/utils/get-credentials.js [app-rsc] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/utils/types.js [app-rsc] (ecmascript)");
/**
 * A Sandbox is an isolated Linux MicroVM to run commands in.
 *
 * Use {@link Sandbox.create} or {@link Sandbox.get} to construct.
 * @hideconstructor
 */ class Sandbox {
    /**
     * Unique ID of this sandbox.
     */ get sandboxId() {
        return this.sandbox.id;
    }
    /**
     * The status of the sandbox.
     */ get status() {
        return this.sandbox.status;
    }
    /**
     * Allow to get a list of sandboxes for a team narrowed to the given params.
     * It returns both the sandboxes and the pagination metadata to allow getting
     * the next page of results.
     */ static async list(params) {
        const credentials = await (0, get_credentials_1.getCredentials)(params);
        const client = new api_client_1.APIClient({
            teamId: credentials.teamId,
            token: credentials.token
        });
        return client.listSandboxes(params);
    }
    /**
     * Create a new sandbox.
     *
     * @param params - Creation parameters and optional credentials.
     * @returns A promise resolving to the created {@link Sandbox}.
     */ static async create(params) {
        const credentials = await (0, get_credentials_1.getCredentials)(params);
        const client = new api_client_1.APIClient({
            teamId: credentials.teamId,
            token: credentials.token
        });
        const privateParams = (0, types_1.getPrivateParams)(params);
        const sandbox = await client.createSandbox({
            source: params?.source,
            projectId: credentials.projectId,
            ports: params?.ports ?? [],
            timeout: params?.timeout,
            resources: params?.resources,
            runtime: params?.runtime,
            ...privateParams
        });
        return new Sandbox({
            client,
            sandbox: sandbox.json.sandbox,
            routes: sandbox.json.routes
        });
    }
    /**
     * Retrieve an existing sandbox.
     *
     * @param params - Get parameters and optional credentials.
     * @returns A promise resolving to the {@link Sandbox}.
     */ static async get(params) {
        const credentials = await (0, get_credentials_1.getCredentials)(params);
        const client = new api_client_1.APIClient({
            teamId: credentials.teamId,
            token: credentials.token
        });
        const sandbox = await client.getSandbox({
            sandboxId: params.sandboxId
        });
        return new Sandbox({
            client,
            sandbox: sandbox.json.sandbox,
            routes: sandbox.json.routes
        });
    }
    /**
     * Create a new Sandbox instance.
     *
     * @param client - API client used to communicate with the backend
     * @param routes - Port-to-subdomain mappings for exposed ports
     * @param sandboxId - Unique identifier for the sandbox
     */ constructor({ client, routes, sandbox }){
        this.client = client;
        this.routes = routes;
        this.sandbox = sandbox;
    }
    /**
     * Get a previously run command by its ID.
     *
     * @param cmdId - ID of the command to retrieve
     * @returns A {@link Command} instance representing the command
     */ async getCommand(cmdId) {
        const command = await this.client.getCommand({
            sandboxId: this.sandbox.id,
            cmdId
        });
        return new command_1.Command({
            client: this.client,
            sandboxId: this.sandbox.id,
            cmd: command.json.command
        });
    }
    async runCommand(commandOrParams, args) {
        return typeof commandOrParams === "string" ? this._runCommand({
            cmd: commandOrParams,
            args
        }) : this._runCommand(commandOrParams);
    }
    /**
     * Internal helper to start a command in the sandbox.
     *
     * @param params - Command execution parameters.
     * @returns A {@link Command} or {@link CommandFinished}, depending on `detached`.
     * @internal
     */ async _runCommand(params) {
        const commandResponse = await this.client.runCommand({
            sandboxId: this.sandbox.id,
            command: params.cmd,
            args: params.args ?? [],
            cwd: params.cwd,
            env: params.env ?? {},
            sudo: params.sudo ?? false
        });
        const command = new command_1.Command({
            client: this.client,
            sandboxId: this.sandbox.id,
            cmd: commandResponse.json.command
        });
        if (params.stdout || params.stderr) {
            (async ()=>{
                for await (const log of command.logs()){
                    if (log.stream === "stdout") {
                        params.stdout?.write(log.data);
                    } else if (log.stream === "stderr") {
                        params.stderr?.write(log.data);
                    }
                }
            })();
        }
        return params.detached ? command : command.wait();
    }
    /**
     * Create a directory in the filesystem of this sandbox.
     *
     * @param path - Path of the directory to create
     */ async mkDir(path) {
        await this.client.mkDir({
            sandboxId: this.sandbox.id,
            path: path
        });
    }
    /**
     * Read a file from the filesystem of this sandbox.
     *
     * @param file - File to read, with path and optional cwd
     * @returns A promise that resolves to a ReadableStream containing the file contents
     */ async readFile(file) {
        return this.client.readFile({
            sandboxId: this.sandbox.id,
            path: file.path,
            cwd: file.cwd
        });
    }
    /**
     * Write files to the filesystem of this sandbox.
     * Defaults to writing to /vercel/sandbox unless an absolute path is specified.
     * Writes files using the `vercel-sandbox` user.
     *
     * @param files - Array of files with path and stream/buffer contents
     * @returns A promise that resolves when the files are written
     */ async writeFiles(files) {
        return this.client.writeFiles({
            sandboxId: this.sandbox.id,
            cwd: this.sandbox.cwd,
            extractDir: "/",
            files: files
        });
    }
    /**
     * Get the public domain of a port of this sandbox.
     *
     * @param p - Port number to resolve
     * @returns A full domain (e.g. `https://subdomain.vercel.run`)
     * @throws If the port has no associated route
     */ domain(p) {
        const route = this.routes.find(({ port })=>port == p);
        if (route) {
            return `https://${route.subdomain}.vercel.run`;
        } else {
            throw new Error(`No route for port ${p}`);
        }
    }
    /**
     * Stop the sandbox.
     *
     * @returns A promise that resolves when the sandbox is stopped
     */ async stop() {
        await this.client.stopSandbox({
            sandboxId: this.sandbox.id
        });
    }
}
exports.Sandbox = Sandbox;
}),
"[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CommandFinished = exports.Command = exports.Sandbox = void 0;
var sandbox_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/sandbox.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "Sandbox", {
    enumerable: true,
    get: function() {
        return sandbox_1.Sandbox;
    }
});
var command_1 = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/command.js [app-rsc] (ecmascript)");
Object.defineProperty(exports, "Command", {
    enumerable: true,
    get: function() {
        return command_1.Command;
    }
});
Object.defineProperty(exports, "CommandFinished", {
    enumerable: true,
    get: function() {
        return command_1.CommandFinished;
    }
});
}),
"[project]/node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

function RetryOperation(timeouts, options) {
    // Compatibility for the old (timeouts, retryForever) signature
    if (typeof options === 'boolean') {
        options = {
            forever: options
        };
    }
    this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
    this._timeouts = timeouts;
    this._options = options || {};
    this._maxRetryTime = options && options.maxRetryTime || Infinity;
    this._fn = null;
    this._errors = [];
    this._attempts = 1;
    this._operationTimeout = null;
    this._operationTimeoutCb = null;
    this._timeout = null;
    this._operationStart = null;
    this._timer = null;
    if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
    }
}
module.exports = RetryOperation;
RetryOperation.prototype.reset = function() {
    this._attempts = 1;
    this._timeouts = this._originalTimeouts.slice(0);
};
RetryOperation.prototype.stop = function() {
    if (this._timeout) {
        clearTimeout(this._timeout);
    }
    if (this._timer) {
        clearTimeout(this._timer);
    }
    this._timeouts = [];
    this._cachedTimeouts = null;
};
RetryOperation.prototype.retry = function(err) {
    if (this._timeout) {
        clearTimeout(this._timeout);
    }
    if (!err) {
        return false;
    }
    var currentTime = new Date().getTime();
    if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error('RetryOperation timeout occurred'));
        return false;
    }
    this._errors.push(err);
    var timeout = this._timeouts.shift();
    if (timeout === undefined) {
        if (this._cachedTimeouts) {
            // retry forever, only keep last error
            this._errors.splice(0, this._errors.length - 1);
            timeout = this._cachedTimeouts.slice(-1);
        } else {
            return false;
        }
    }
    var self = this;
    this._timer = setTimeout(function() {
        self._attempts++;
        if (self._operationTimeoutCb) {
            self._timeout = setTimeout(function() {
                self._operationTimeoutCb(self._attempts);
            }, self._operationTimeout);
            if (self._options.unref) {
                self._timeout.unref();
            }
        }
        self._fn(self._attempts);
    }, timeout);
    if (this._options.unref) {
        this._timer.unref();
    }
    return true;
};
RetryOperation.prototype.attempt = function(fn, timeoutOps) {
    this._fn = fn;
    if (timeoutOps) {
        if (timeoutOps.timeout) {
            this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
            this._operationTimeoutCb = timeoutOps.cb;
        }
    }
    var self = this;
    if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
            self._operationTimeoutCb();
        }, self._operationTimeout);
    }
    this._operationStart = new Date().getTime();
    this._fn(this._attempts);
};
RetryOperation.prototype.try = function(fn) {
    console.log('Using RetryOperation.try() is deprecated');
    this.attempt(fn);
};
RetryOperation.prototype.start = function(fn) {
    console.log('Using RetryOperation.start() is deprecated');
    this.attempt(fn);
};
RetryOperation.prototype.start = RetryOperation.prototype.try;
RetryOperation.prototype.errors = function() {
    return this._errors;
};
RetryOperation.prototype.attempts = function() {
    return this._attempts;
};
RetryOperation.prototype.mainError = function() {
    if (this._errors.length === 0) {
        return null;
    }
    var counts = {};
    var mainError = null;
    var mainErrorCount = 0;
    for(var i = 0; i < this._errors.length; i++){
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
            mainError = error;
            mainErrorCount = count;
        }
    }
    return mainError;
};
}),
"[project]/node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

var RetryOperation = __turbopack_context__.r("[project]/node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry_operation.js [app-rsc] (ecmascript)");
exports.operation = function(options) {
    var timeouts = exports.timeouts(options);
    return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
    });
};
exports.timeouts = function(options) {
    if (options instanceof Array) {
        return [].concat(options);
    }
    var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1000,
        maxTimeout: Infinity,
        randomize: false
    };
    for(var key in options){
        opts[key] = options[key];
    }
    if (opts.minTimeout > opts.maxTimeout) {
        throw new Error('minTimeout is greater than maxTimeout');
    }
    var timeouts = [];
    for(var i = 0; i < opts.retries; i++){
        timeouts.push(this.createTimeout(i, opts));
    }
    if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
    }
    // sort the array numerically ascending
    timeouts.sort(function(a, b) {
        return a - b;
    });
    return timeouts;
};
exports.createTimeout = function(attempt, opts) {
    var random = opts.randomize ? Math.random() + 1 : 1;
    var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
    timeout = Math.min(timeout, opts.maxTimeout);
    return timeout;
};
exports.wrap = function(obj, options, methods) {
    if (options instanceof Array) {
        methods = options;
        options = null;
    }
    if (!methods) {
        methods = [];
        for(var key in obj){
            if (typeof obj[key] === 'function') {
                methods.push(key);
            }
        }
    }
    for(var i = 0; i < methods.length; i++){
        var method = methods[i];
        var original = obj[method];
        obj[method] = (function retryWrapper(original) {
            var op = exports.operation(options);
            var args = Array.prototype.slice.call(arguments, 1);
            var callback = args.pop();
            args.push(function(err) {
                if (op.retry(err)) {
                    return;
                }
                if (err) {
                    arguments[0] = op.mainError();
                }
                callback.apply(this, arguments);
            });
            op.attempt(function() {
                original.apply(obj, args);
            });
        }).bind(obj, original);
        obj[method].options = options;
    }
};
}),
"[project]/node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[project]/node_modules/.pnpm/retry@0.13.1/node_modules/retry/lib/retry.js [app-rsc] (ecmascript)");
}),
"[project]/node_modules/.pnpm/async-retry@1.3.3/node_modules/async-retry/lib/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

// Packages
var retrier = __turbopack_context__.r("[project]/node_modules/.pnpm/retry@0.13.1/node_modules/retry/index.js [app-rsc] (ecmascript)");
function retry(fn, opts) {
    function run(resolve, reject) {
        var options = opts || {};
        var op;
        // Default `randomize` to true
        if (!('randomize' in options)) {
            options.randomize = true;
        }
        op = retrier.operation(options);
        // We allow the user to abort retrying
        // this makes sense in the cases where
        // knowledge is obtained that retrying
        // would be futile (e.g.: auth errors)
        function bail(err) {
            reject(err || new Error('Aborted'));
        }
        function onError(err, num) {
            if (err.bail) {
                bail(err);
                return;
            }
            if (!op.retry(err)) {
                reject(op.mainError());
            } else if (options.onRetry) {
                options.onRetry(err, num);
            }
        }
        function runAttempt(num) {
            var val;
            try {
                val = fn(bail, num);
            } catch (err) {
                onError(err, num);
                return;
            }
            Promise.resolve(val).then(resolve).catch(function catchIt(err) {
                onError(err, num);
            });
        }
        op.attempt(runAttempt);
    }
    return new Promise(run);
}
module.exports = retry;
}),
"[project]/node_modules/.pnpm/events-universal@1.0.1/node_modules/events-universal/default.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[externals]/events [external] (events, cjs)");
}),
"[project]/node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/fixed-size.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = class FixedFIFO {
    constructor(hwm){
        if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) throw new Error('Max size for a FixedFIFO should be a power of two');
        this.buffer = new Array(hwm);
        this.mask = hwm - 1;
        this.top = 0;
        this.btm = 0;
        this.next = null;
    }
    clear() {
        this.top = this.btm = 0;
        this.next = null;
        this.buffer.fill(undefined);
    }
    push(data) {
        if (this.buffer[this.top] !== undefined) return false;
        this.buffer[this.top] = data;
        this.top = this.top + 1 & this.mask;
        return true;
    }
    shift() {
        const last = this.buffer[this.btm];
        if (last === undefined) return undefined;
        this.buffer[this.btm] = undefined;
        this.btm = this.btm + 1 & this.mask;
        return last;
    }
    peek() {
        return this.buffer[this.btm];
    }
    isEmpty() {
        return this.buffer[this.btm] === undefined;
    }
};
}),
"[project]/node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

const FixedFIFO = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/fixed-size.js [app-rsc] (ecmascript)");
module.exports = class FastFIFO {
    constructor(hwm){
        this.hwm = hwm || 16;
        this.head = new FixedFIFO(this.hwm);
        this.tail = this.head;
        this.length = 0;
    }
    clear() {
        this.head = this.tail;
        this.head.clear();
        this.length = 0;
    }
    push(val) {
        this.length++;
        if (!this.head.push(val)) {
            const prev = this.head;
            this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
            this.head.push(val);
        }
    }
    shift() {
        if (this.length !== 0) this.length--;
        const val = this.tail.shift();
        if (val === undefined && this.tail.next) {
            const next = this.tail.next;
            this.tail.next = null;
            this.tail = next;
            return this.tail.shift();
        }
        return val;
    }
    peek() {
        const val = this.tail.peek();
        if (val === undefined && this.tail.next) return this.tail.next.peek();
        return val;
    }
    isEmpty() {
        return this.length === 0;
    }
};
}),
"[project]/node_modules/.pnpm/b4a@1.7.3/node_modules/b4a/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

function isBuffer(value) {
    return Buffer.isBuffer(value) || value instanceof Uint8Array;
}
function isEncoding(encoding) {
    return Buffer.isEncoding(encoding);
}
function alloc(size, fill, encoding) {
    return Buffer.alloc(size, fill, encoding);
}
function allocUnsafe(size) {
    return Buffer.allocUnsafe(size);
}
function allocUnsafeSlow(size) {
    return Buffer.allocUnsafeSlow(size);
}
function byteLength(string, encoding) {
    return Buffer.byteLength(string, encoding);
}
function compare(a, b) {
    return Buffer.compare(a, b);
}
function concat(buffers, totalLength) {
    return Buffer.concat(buffers, totalLength);
}
function copy(source, target, targetStart, start, end) {
    return toBuffer(source).copy(target, targetStart, start, end);
}
function equals(a, b) {
    return toBuffer(a).equals(b);
}
function fill(buffer, value, offset, end, encoding) {
    return toBuffer(buffer).fill(value, offset, end, encoding);
}
function from(value, encodingOrOffset, length) {
    return Buffer.from(value, encodingOrOffset, length);
}
function includes(buffer, value, byteOffset, encoding) {
    return toBuffer(buffer).includes(value, byteOffset, encoding);
}
function indexOf(buffer, value, byfeOffset, encoding) {
    return toBuffer(buffer).indexOf(value, byfeOffset, encoding);
}
function lastIndexOf(buffer, value, byteOffset, encoding) {
    return toBuffer(buffer).lastIndexOf(value, byteOffset, encoding);
}
function swap16(buffer) {
    return toBuffer(buffer).swap16();
}
function swap32(buffer) {
    return toBuffer(buffer).swap32();
}
function swap64(buffer) {
    return toBuffer(buffer).swap64();
}
function toBuffer(buffer) {
    if (Buffer.isBuffer(buffer)) return buffer;
    return Buffer.from(buffer.buffer, buffer.byteOffset, buffer.byteLength);
}
function toString(buffer, encoding, start, end) {
    return toBuffer(buffer).toString(encoding, start, end);
}
function write(buffer, string, offset, length, encoding) {
    return toBuffer(buffer).write(string, offset, length, encoding);
}
function readDoubleBE(buffer, offset) {
    return toBuffer(buffer).readDoubleBE(offset);
}
function readDoubleLE(buffer, offset) {
    return toBuffer(buffer).readDoubleLE(offset);
}
function readFloatBE(buffer, offset) {
    return toBuffer(buffer).readFloatBE(offset);
}
function readFloatLE(buffer, offset) {
    return toBuffer(buffer).readFloatLE(offset);
}
function readInt32BE(buffer, offset) {
    return toBuffer(buffer).readInt32BE(offset);
}
function readInt32LE(buffer, offset) {
    return toBuffer(buffer).readInt32LE(offset);
}
function readUInt32BE(buffer, offset) {
    return toBuffer(buffer).readUInt32BE(offset);
}
function readUInt32LE(buffer, offset) {
    return toBuffer(buffer).readUInt32LE(offset);
}
function writeDoubleBE(buffer, value, offset) {
    return toBuffer(buffer).writeDoubleBE(value, offset);
}
function writeDoubleLE(buffer, value, offset) {
    return toBuffer(buffer).writeDoubleLE(value, offset);
}
function writeFloatBE(buffer, value, offset) {
    return toBuffer(buffer).writeFloatBE(value, offset);
}
function writeFloatLE(buffer, value, offset) {
    return toBuffer(buffer).writeFloatLE(value, offset);
}
function writeInt32BE(buffer, value, offset) {
    return toBuffer(buffer).writeInt32BE(value, offset);
}
function writeInt32LE(buffer, value, offset) {
    return toBuffer(buffer).writeInt32LE(value, offset);
}
function writeUInt32BE(buffer, value, offset) {
    return toBuffer(buffer).writeUInt32BE(value, offset);
}
function writeUInt32LE(buffer, value, offset) {
    return toBuffer(buffer).writeUInt32LE(value, offset);
}
module.exports = {
    isBuffer,
    isEncoding,
    alloc,
    allocUnsafe,
    allocUnsafeSlow,
    byteLength,
    compare,
    concat,
    copy,
    equals,
    fill,
    from,
    includes,
    indexOf,
    lastIndexOf,
    swap16,
    swap32,
    swap64,
    toBuffer,
    toString,
    write,
    readDoubleBE,
    readDoubleLE,
    readFloatBE,
    readFloatLE,
    readInt32BE,
    readInt32LE,
    readUInt32BE,
    readUInt32LE,
    writeDoubleBE,
    writeDoubleLE,
    writeFloatBE,
    writeFloatLE,
    writeInt32BE,
    writeInt32LE,
    writeUInt32BE,
    writeUInt32LE
};
}),
"[project]/node_modules/.pnpm/text-decoder@1.2.3/node_modules/text-decoder/lib/pass-through-decoder.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

const b4a = __turbopack_context__.r("[project]/node_modules/.pnpm/b4a@1.7.3/node_modules/b4a/index.js [app-rsc] (ecmascript)");
module.exports = class PassThroughDecoder {
    constructor(encoding){
        this.encoding = encoding;
    }
    get remaining() {
        return 0;
    }
    decode(tail) {
        return b4a.toString(tail, this.encoding);
    }
    flush() {
        return '';
    }
};
}),
"[project]/node_modules/.pnpm/text-decoder@1.2.3/node_modules/text-decoder/lib/utf8-decoder.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

const b4a = __turbopack_context__.r("[project]/node_modules/.pnpm/b4a@1.7.3/node_modules/b4a/index.js [app-rsc] (ecmascript)");
/**
 * https://encoding.spec.whatwg.org/#utf-8-decoder
 */ module.exports = class UTF8Decoder {
    constructor(){
        this.codePoint = 0;
        this.bytesSeen = 0;
        this.bytesNeeded = 0;
        this.lowerBoundary = 0x80;
        this.upperBoundary = 0xbf;
    }
    get remaining() {
        return this.bytesSeen;
    }
    decode(data) {
        // If we have a fast path, just sniff if the last part is a boundary
        if (this.bytesNeeded === 0) {
            let isBoundary = true;
            for(let i = Math.max(0, data.byteLength - 4), n = data.byteLength; i < n && isBoundary; i++){
                isBoundary = data[i] <= 0x7f;
            }
            if (isBoundary) return b4a.toString(data, 'utf8');
        }
        let result = '';
        for(let i = 0, n = data.byteLength; i < n; i++){
            const byte = data[i];
            if (this.bytesNeeded === 0) {
                if (byte <= 0x7f) {
                    result += String.fromCharCode(byte);
                } else {
                    this.bytesSeen = 1;
                    if (byte >= 0xc2 && byte <= 0xdf) {
                        this.bytesNeeded = 2;
                        this.codePoint = byte & 0x1f;
                    } else if (byte >= 0xe0 && byte <= 0xef) {
                        if (byte === 0xe0) this.lowerBoundary = 0xa0;
                        else if (byte === 0xed) this.upperBoundary = 0x9f;
                        this.bytesNeeded = 3;
                        this.codePoint = byte & 0xf;
                    } else if (byte >= 0xf0 && byte <= 0xf4) {
                        if (byte === 0xf0) this.lowerBoundary = 0x90;
                        if (byte === 0xf4) this.upperBoundary = 0x8f;
                        this.bytesNeeded = 4;
                        this.codePoint = byte & 0x7;
                    } else {
                        result += '\ufffd';
                    }
                }
                continue;
            }
            if (byte < this.lowerBoundary || byte > this.upperBoundary) {
                this.codePoint = 0;
                this.bytesNeeded = 0;
                this.bytesSeen = 0;
                this.lowerBoundary = 0x80;
                this.upperBoundary = 0xbf;
                result += '\ufffd';
                continue;
            }
            this.lowerBoundary = 0x80;
            this.upperBoundary = 0xbf;
            this.codePoint = this.codePoint << 6 | byte & 0x3f;
            this.bytesSeen++;
            if (this.bytesSeen !== this.bytesNeeded) continue;
            result += String.fromCodePoint(this.codePoint);
            this.codePoint = 0;
            this.bytesNeeded = 0;
            this.bytesSeen = 0;
        }
        return result;
    }
    flush() {
        const result = this.bytesNeeded > 0 ? '\ufffd' : '';
        this.codePoint = 0;
        this.bytesNeeded = 0;
        this.bytesSeen = 0;
        this.lowerBoundary = 0x80;
        this.upperBoundary = 0xbf;
        return result;
    }
};
}),
"[project]/node_modules/.pnpm/text-decoder@1.2.3/node_modules/text-decoder/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

const PassThroughDecoder = __turbopack_context__.r("[project]/node_modules/.pnpm/text-decoder@1.2.3/node_modules/text-decoder/lib/pass-through-decoder.js [app-rsc] (ecmascript)");
const UTF8Decoder = __turbopack_context__.r("[project]/node_modules/.pnpm/text-decoder@1.2.3/node_modules/text-decoder/lib/utf8-decoder.js [app-rsc] (ecmascript)");
module.exports = class TextDecoder {
    constructor(encoding = 'utf8'){
        this.encoding = normalizeEncoding(encoding);
        switch(this.encoding){
            case 'utf8':
                this.decoder = new UTF8Decoder();
                break;
            case 'utf16le':
            case 'base64':
                throw new Error('Unsupported encoding: ' + this.encoding);
            default:
                this.decoder = new PassThroughDecoder(this.encoding);
        }
    }
    get remaining() {
        return this.decoder.remaining;
    }
    push(data) {
        if (typeof data === 'string') return data;
        return this.decoder.decode(data);
    }
    // For Node.js compatibility
    write(data) {
        return this.push(data);
    }
    end(data) {
        let result = '';
        if (data) result = this.push(data);
        result += this.decoder.flush();
        return result;
    }
};
function normalizeEncoding(encoding) {
    encoding = encoding.toLowerCase();
    switch(encoding){
        case 'utf8':
        case 'utf-8':
            return 'utf8';
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return 'utf16le';
        case 'latin1':
        case 'binary':
            return 'latin1';
        case 'base64':
        case 'ascii':
        case 'hex':
            return encoding;
        default:
            throw new Error('Unknown encoding: ' + encoding);
    }
}
;
}),
"[project]/node_modules/.pnpm/streamx@2.23.0/node_modules/streamx/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

const { EventEmitter } = __turbopack_context__.r("[project]/node_modules/.pnpm/events-universal@1.0.1/node_modules/events-universal/default.js [app-rsc] (ecmascript)");
const STREAM_DESTROYED = new Error('Stream was destroyed');
const PREMATURE_CLOSE = new Error('Premature close');
const FIFO = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/index.js [app-rsc] (ecmascript)");
const TextDecoder = __turbopack_context__.r("[project]/node_modules/.pnpm/text-decoder@1.2.3/node_modules/text-decoder/index.js [app-rsc] (ecmascript)");
// if we do a future major, expect queue microtask to be there always, for now a bit defensive
const qmt = typeof queueMicrotask === 'undefined' ? (fn)=>/*TURBOPACK member replacement*/ __turbopack_context__.g.process.nextTick(fn) : queueMicrotask;
/* eslint-disable no-multi-spaces */ // 29 bits used total (4 from shared, 14 from read, and 11 from write)
const MAX = (1 << 29) - 1;
// Shared state
const OPENING = 0b0001;
const PREDESTROYING = 0b0010;
const DESTROYING = 0b0100;
const DESTROYED = 0b1000;
const NOT_OPENING = MAX ^ OPENING;
const NOT_PREDESTROYING = MAX ^ PREDESTROYING;
// Read state (4 bit offset from shared state)
const READ_ACTIVE = 0b00000000000001 << 4;
const READ_UPDATING = 0b00000000000010 << 4;
const READ_PRIMARY = 0b00000000000100 << 4;
const READ_QUEUED = 0b00000000001000 << 4;
const READ_RESUMED = 0b00000000010000 << 4;
const READ_PIPE_DRAINED = 0b00000000100000 << 4;
const READ_ENDING = 0b00000001000000 << 4;
const READ_EMIT_DATA = 0b00000010000000 << 4;
const READ_EMIT_READABLE = 0b00000100000000 << 4;
const READ_EMITTED_READABLE = 0b00001000000000 << 4;
const READ_DONE = 0b00010000000000 << 4;
const READ_NEXT_TICK = 0b00100000000000 << 4;
const READ_NEEDS_PUSH = 0b01000000000000 << 4;
const READ_READ_AHEAD = 0b10000000000000 << 4;
// Combined read state
const READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED;
const READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH;
const READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE;
const READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED;
const READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD;
const READ_NOT_ACTIVE = MAX ^ READ_ACTIVE;
const READ_NON_PRIMARY = MAX ^ READ_PRIMARY;
const READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH);
const READ_PUSHED = MAX ^ READ_NEEDS_PUSH;
const READ_PAUSED = MAX ^ READ_RESUMED;
const READ_NOT_QUEUED = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE);
const READ_NOT_ENDING = MAX ^ READ_ENDING;
const READ_PIPE_NOT_DRAINED = MAX ^ READ_FLOWING;
const READ_NOT_NEXT_TICK = MAX ^ READ_NEXT_TICK;
const READ_NOT_UPDATING = MAX ^ READ_UPDATING;
const READ_NO_READ_AHEAD = MAX ^ READ_READ_AHEAD;
const READ_PAUSED_NO_READ_AHEAD = MAX ^ READ_RESUMED_READ_AHEAD;
// Write state (18 bit offset, 4 bit offset from shared state and 14 from read state)
const WRITE_ACTIVE = 0b00000000001 << 18;
const WRITE_UPDATING = 0b00000000010 << 18;
const WRITE_PRIMARY = 0b00000000100 << 18;
const WRITE_QUEUED = 0b00000001000 << 18;
const WRITE_UNDRAINED = 0b00000010000 << 18;
const WRITE_DONE = 0b00000100000 << 18;
const WRITE_EMIT_DRAIN = 0b00001000000 << 18;
const WRITE_NEXT_TICK = 0b00010000000 << 18;
const WRITE_WRITING = 0b00100000000 << 18;
const WRITE_FINISHING = 0b01000000000 << 18;
const WRITE_CORKED = 0b10000000000 << 18;
const WRITE_NOT_ACTIVE = MAX ^ (WRITE_ACTIVE | WRITE_WRITING);
const WRITE_NON_PRIMARY = MAX ^ WRITE_PRIMARY;
const WRITE_NOT_FINISHING = MAX ^ (WRITE_ACTIVE | WRITE_FINISHING);
const WRITE_DRAINED = MAX ^ WRITE_UNDRAINED;
const WRITE_NOT_QUEUED = MAX ^ WRITE_QUEUED;
const WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK;
const WRITE_NOT_UPDATING = MAX ^ WRITE_UPDATING;
const WRITE_NOT_CORKED = MAX ^ WRITE_CORKED;
// Combined shared state
const ACTIVE = READ_ACTIVE | WRITE_ACTIVE;
const NOT_ACTIVE = MAX ^ ACTIVE;
const DONE = READ_DONE | WRITE_DONE;
const DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING;
const OPEN_STATUS = DESTROY_STATUS | OPENING;
const AUTO_DESTROY = DESTROY_STATUS | DONE;
const NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY;
const ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK;
const TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE;
const IS_OPENING = OPEN_STATUS | TICKING;
// Combined shared state and read state
const READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE;
const READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED;
const READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED;
const READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE;
const SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD;
const READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE;
const READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY;
const READ_NEXT_TICK_OR_OPENING = READ_NEXT_TICK | OPENING;
// Combined write state
const WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE;
const WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED;
const WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE;
const WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE;
const WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED;
const WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE;
const WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING;
const WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE;
const WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE;
const WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY;
const WRITE_DROP_DATA = WRITE_FINISHING | WRITE_DONE | DESTROY_STATUS;
const asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator');
class WritableState {
    constructor(stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}){
        this.stream = stream;
        this.queue = new FIFO();
        this.highWaterMark = highWaterMark;
        this.buffered = 0;
        this.error = null;
        this.pipeline = null;
        this.drains = null; // if we add more seldomly used helpers we might them into a subobject so its a single ptr
        this.byteLength = byteLengthWritable || byteLength || defaultByteLength;
        this.map = mapWritable || map;
        this.afterWrite = afterWrite.bind(this);
        this.afterUpdateNextTick = updateWriteNT.bind(this);
    }
    get ended() {
        return (this.stream._duplexState & WRITE_DONE) !== 0;
    }
    push(data) {
        if ((this.stream._duplexState & WRITE_DROP_DATA) !== 0) return false;
        if (this.map !== null) data = this.map(data);
        this.buffered += this.byteLength(data);
        this.queue.push(data);
        if (this.buffered < this.highWaterMark) {
            this.stream._duplexState |= WRITE_QUEUED;
            return true;
        }
        this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED;
        return false;
    }
    shift() {
        const data = this.queue.shift();
        this.buffered -= this.byteLength(data);
        if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED;
        return data;
    }
    end(data) {
        if (typeof data === 'function') this.stream.once('finish', data);
        else if (data !== undefined && data !== null) this.push(data);
        this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY;
    }
    autoBatch(data, cb) {
        const buffer = [];
        const stream = this.stream;
        buffer.push(data);
        while((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE){
            buffer.push(stream._writableState.shift());
        }
        if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null);
        stream._writev(buffer, cb);
    }
    update() {
        const stream = this.stream;
        stream._duplexState |= WRITE_UPDATING;
        do {
            while((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED){
                const data = this.shift();
                stream._duplexState |= WRITE_ACTIVE_AND_WRITING;
                stream._write(data, this.afterWrite);
            }
            if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();
        }while (this.continueUpdate() === true)
        stream._duplexState &= WRITE_NOT_UPDATING;
    }
    updateNonPrimary() {
        const stream = this.stream;
        if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {
            stream._duplexState = stream._duplexState | WRITE_ACTIVE;
            stream._final(afterFinal.bind(this));
            return;
        }
        if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
            if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
                stream._duplexState |= ACTIVE;
                stream._destroy(afterDestroy.bind(this));
            }
            return;
        }
        if ((stream._duplexState & IS_OPENING) === OPENING) {
            stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
            stream._open(afterOpen.bind(this));
        }
    }
    continueUpdate() {
        if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false;
        this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
        return true;
    }
    updateCallback() {
        if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update();
        else this.updateNextTick();
    }
    updateNextTick() {
        if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return;
        this.stream._duplexState |= WRITE_NEXT_TICK;
        if ((this.stream._duplexState & WRITE_UPDATING) === 0) qmt(this.afterUpdateNextTick);
    }
}
class ReadableState {
    constructor(stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}){
        this.stream = stream;
        this.queue = new FIFO();
        this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark;
        this.buffered = 0;
        this.readAhead = highWaterMark > 0;
        this.error = null;
        this.pipeline = null;
        this.byteLength = byteLengthReadable || byteLength || defaultByteLength;
        this.map = mapReadable || map;
        this.pipeTo = null;
        this.afterRead = afterRead.bind(this);
        this.afterUpdateNextTick = updateReadNT.bind(this);
    }
    get ended() {
        return (this.stream._duplexState & READ_DONE) !== 0;
    }
    pipe(pipeTo, cb) {
        if (this.pipeTo !== null) throw new Error('Can only pipe to one destination');
        if (typeof cb !== 'function') cb = null;
        this.stream._duplexState |= READ_PIPE_DRAINED;
        this.pipeTo = pipeTo;
        this.pipeline = new Pipeline(this.stream, pipeTo, cb);
        if (cb) this.stream.on('error', noop); // We already error handle this so supress crashes
        if (isStreamx(pipeTo)) {
            pipeTo._writableState.pipeline = this.pipeline;
            if (cb) pipeTo.on('error', noop); // We already error handle this so supress crashes
            pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline)); // TODO: just call finished from pipeTo itself
        } else {
            const onerror = this.pipeline.done.bind(this.pipeline, pipeTo);
            const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null) // onclose has a weird bool arg
            ;
            pipeTo.on('error', onerror);
            pipeTo.on('close', onclose);
            pipeTo.on('finish', this.pipeline.finished.bind(this.pipeline));
        }
        pipeTo.on('drain', afterDrain.bind(this));
        this.stream.emit('piping', pipeTo);
        pipeTo.emit('pipe', this.stream);
    }
    push(data) {
        const stream = this.stream;
        if (data === null) {
            this.highWaterMark = 0;
            stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED;
            return false;
        }
        if (this.map !== null) {
            data = this.map(data);
            if (data === null) {
                stream._duplexState &= READ_PUSHED;
                return this.buffered < this.highWaterMark;
            }
        }
        this.buffered += this.byteLength(data);
        this.queue.push(data);
        stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED;
        return this.buffered < this.highWaterMark;
    }
    shift() {
        const data = this.queue.shift();
        this.buffered -= this.byteLength(data);
        if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED;
        return data;
    }
    unshift(data) {
        const pending = [
            this.map !== null ? this.map(data) : data
        ];
        while(this.buffered > 0)pending.push(this.shift());
        for(let i = 0; i < pending.length - 1; i++){
            const data = pending[i];
            this.buffered += this.byteLength(data);
            this.queue.push(data);
        }
        this.push(pending[pending.length - 1]);
    }
    read() {
        const stream = this.stream;
        if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {
            const data = this.shift();
            if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;
            if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data);
            return data;
        }
        if (this.readAhead === false) {
            stream._duplexState |= READ_READ_AHEAD;
            this.updateNextTick();
        }
        return null;
    }
    drain() {
        const stream = this.stream;
        while((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0){
            const data = this.shift();
            if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;
            if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit('data', data);
        }
    }
    update() {
        const stream = this.stream;
        stream._duplexState |= READ_UPDATING;
        do {
            this.drain();
            while(this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD){
                stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH;
                stream._read(this.afterRead);
                this.drain();
            }
            if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {
                stream._duplexState |= READ_EMITTED_READABLE;
                stream.emit('readable');
            }
            if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();
        }while (this.continueUpdate() === true)
        stream._duplexState &= READ_NOT_UPDATING;
    }
    updateNonPrimary() {
        const stream = this.stream;
        if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {
            stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING;
            stream.emit('end');
            if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING;
            if (this.pipeTo !== null) this.pipeTo.end();
        }
        if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
            if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
                stream._duplexState |= ACTIVE;
                stream._destroy(afterDestroy.bind(this));
            }
            return;
        }
        if ((stream._duplexState & IS_OPENING) === OPENING) {
            stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
            stream._open(afterOpen.bind(this));
        }
    }
    continueUpdate() {
        if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false;
        this.stream._duplexState &= READ_NOT_NEXT_TICK;
        return true;
    }
    updateCallback() {
        if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update();
        else this.updateNextTick();
    }
    updateNextTickIfOpen() {
        if ((this.stream._duplexState & READ_NEXT_TICK_OR_OPENING) !== 0) return;
        this.stream._duplexState |= READ_NEXT_TICK;
        if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick);
    }
    updateNextTick() {
        if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return;
        this.stream._duplexState |= READ_NEXT_TICK;
        if ((this.stream._duplexState & READ_UPDATING) === 0) qmt(this.afterUpdateNextTick);
    }
}
class TransformState {
    constructor(stream){
        this.data = null;
        this.afterTransform = afterTransform.bind(stream);
        this.afterFinal = null;
    }
}
class Pipeline {
    constructor(src, dst, cb){
        this.from = src;
        this.to = dst;
        this.afterPipe = cb;
        this.error = null;
        this.pipeToFinished = false;
    }
    finished() {
        this.pipeToFinished = true;
    }
    done(stream, err) {
        if (err) this.error = err;
        if (stream === this.to) {
            this.to = null;
            if (this.from !== null) {
                if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {
                    this.from.destroy(this.error || new Error('Writable stream closed prematurely'));
                }
                return;
            }
        }
        if (stream === this.from) {
            this.from = null;
            if (this.to !== null) {
                if ((stream._duplexState & READ_DONE) === 0) {
                    this.to.destroy(this.error || new Error('Readable stream closed before ending'));
                }
                return;
            }
        }
        if (this.afterPipe !== null) this.afterPipe(this.error);
        this.to = this.from = this.afterPipe = null;
    }
}
function afterDrain() {
    this.stream._duplexState |= READ_PIPE_DRAINED;
    this.updateCallback();
}
function afterFinal(err) {
    const stream = this.stream;
    if (err) stream.destroy(err);
    if ((stream._duplexState & DESTROY_STATUS) === 0) {
        stream._duplexState |= WRITE_DONE;
        stream.emit('finish');
    }
    if ((stream._duplexState & AUTO_DESTROY) === DONE) {
        stream._duplexState |= DESTROYING;
    }
    stream._duplexState &= WRITE_NOT_FINISHING;
    // no need to wait the extra tick here, so we short circuit that
    if ((stream._duplexState & WRITE_UPDATING) === 0) this.update();
    else this.updateNextTick();
}
function afterDestroy(err) {
    const stream = this.stream;
    if (!err && this.error !== STREAM_DESTROYED) err = this.error;
    if (err) stream.emit('error', err);
    stream._duplexState |= DESTROYED;
    stream.emit('close');
    const rs = stream._readableState;
    const ws = stream._writableState;
    if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err);
    if (ws !== null) {
        while(ws.drains !== null && ws.drains.length > 0)ws.drains.shift().resolve(false);
        if (ws.pipeline !== null) ws.pipeline.done(stream, err);
    }
}
function afterWrite(err) {
    const stream = this.stream;
    if (err) stream.destroy(err);
    stream._duplexState &= WRITE_NOT_ACTIVE;
    if (this.drains !== null) tickDrains(this.drains);
    if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {
        stream._duplexState &= WRITE_DRAINED;
        if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {
            stream.emit('drain');
        }
    }
    this.updateCallback();
}
function afterRead(err) {
    if (err) this.stream.destroy(err);
    this.stream._duplexState &= READ_NOT_ACTIVE;
    if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD;
    this.updateCallback();
}
function updateReadNT() {
    if ((this.stream._duplexState & READ_UPDATING) === 0) {
        this.stream._duplexState &= READ_NOT_NEXT_TICK;
        this.update();
    }
}
function updateWriteNT() {
    if ((this.stream._duplexState & WRITE_UPDATING) === 0) {
        this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
        this.update();
    }
}
function tickDrains(drains) {
    for(let i = 0; i < drains.length; i++){
        // drains.writes are monotonic, so if one is 0 its always the first one
        if (--drains[i].writes === 0) {
            drains.shift().resolve(true);
            i--;
        }
    }
}
function afterOpen(err) {
    const stream = this.stream;
    if (err) stream.destroy(err);
    if ((stream._duplexState & DESTROYING) === 0) {
        if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY;
        if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY;
        stream.emit('open');
    }
    stream._duplexState &= NOT_ACTIVE;
    if (stream._writableState !== null) {
        stream._writableState.updateCallback();
    }
    if (stream._readableState !== null) {
        stream._readableState.updateCallback();
    }
}
function afterTransform(err, data) {
    if (data !== undefined && data !== null) this.push(data);
    this._writableState.afterWrite(err);
}
function newListener(name) {
    if (this._readableState !== null) {
        if (name === 'data') {
            this._duplexState |= READ_EMIT_DATA | READ_RESUMED_READ_AHEAD;
            this._readableState.updateNextTick();
        }
        if (name === 'readable') {
            this._duplexState |= READ_EMIT_READABLE;
            this._readableState.updateNextTick();
        }
    }
    if (this._writableState !== null) {
        if (name === 'drain') {
            this._duplexState |= WRITE_EMIT_DRAIN;
            this._writableState.updateNextTick();
        }
    }
}
class Stream extends EventEmitter {
    constructor(opts){
        super();
        this._duplexState = 0;
        this._readableState = null;
        this._writableState = null;
        if (opts) {
            if (opts.open) this._open = opts.open;
            if (opts.destroy) this._destroy = opts.destroy;
            if (opts.predestroy) this._predestroy = opts.predestroy;
            if (opts.signal) {
                opts.signal.addEventListener('abort', abort.bind(this));
            }
        }
        this.on('newListener', newListener);
    }
    _open(cb) {
        cb(null);
    }
    _destroy(cb) {
        cb(null);
    }
    _predestroy() {
    // does nothing
    }
    get readable() {
        return this._readableState !== null ? true : undefined;
    }
    get writable() {
        return this._writableState !== null ? true : undefined;
    }
    get destroyed() {
        return (this._duplexState & DESTROYED) !== 0;
    }
    get destroying() {
        return (this._duplexState & DESTROY_STATUS) !== 0;
    }
    destroy(err) {
        if ((this._duplexState & DESTROY_STATUS) === 0) {
            if (!err) err = STREAM_DESTROYED;
            this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY;
            if (this._readableState !== null) {
                this._readableState.highWaterMark = 0;
                this._readableState.error = err;
            }
            if (this._writableState !== null) {
                this._writableState.highWaterMark = 0;
                this._writableState.error = err;
            }
            this._duplexState |= PREDESTROYING;
            this._predestroy();
            this._duplexState &= NOT_PREDESTROYING;
            if (this._readableState !== null) this._readableState.updateNextTick();
            if (this._writableState !== null) this._writableState.updateNextTick();
        }
    }
}
class Readable extends Stream {
    constructor(opts){
        super(opts);
        this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD;
        this._readableState = new ReadableState(this, opts);
        if (opts) {
            if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD;
            if (opts.read) this._read = opts.read;
            if (opts.eagerOpen) this._readableState.updateNextTick();
            if (opts.encoding) this.setEncoding(opts.encoding);
        }
    }
    setEncoding(encoding) {
        const dec = new TextDecoder(encoding);
        const map = this._readableState.map || echo;
        this._readableState.map = mapOrSkip;
        return this;
        //TURBOPACK unreachable
        ;
        function mapOrSkip(data) {
            const next = dec.push(data);
            return next === '' && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next);
        }
    }
    _read(cb) {
        cb(null);
    }
    pipe(dest, cb) {
        this._readableState.updateNextTick();
        this._readableState.pipe(dest, cb);
        return dest;
    }
    read() {
        this._readableState.updateNextTick();
        return this._readableState.read();
    }
    push(data) {
        this._readableState.updateNextTickIfOpen();
        return this._readableState.push(data);
    }
    unshift(data) {
        this._readableState.updateNextTickIfOpen();
        return this._readableState.unshift(data);
    }
    resume() {
        this._duplexState |= READ_RESUMED_READ_AHEAD;
        this._readableState.updateNextTick();
        return this;
    }
    pause() {
        this._duplexState &= this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED;
        return this;
    }
    static _fromAsyncIterator(ite, opts) {
        let destroy;
        const rs = new Readable({
            ...opts,
            read (cb) {
                ite.next().then(push).then(cb.bind(null, null)).catch(cb);
            },
            predestroy () {
                destroy = ite.return();
            },
            destroy (cb) {
                if (!destroy) return cb(null);
                destroy.then(cb.bind(null, null)).catch(cb);
            }
        });
        return rs;
        //TURBOPACK unreachable
        ;
        function push(data) {
            if (data.done) rs.push(null);
            else rs.push(data.value);
        }
    }
    static from(data, opts) {
        if (isReadStreamx(data)) return data;
        if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts);
        if (!Array.isArray(data)) data = data === undefined ? [] : [
            data
        ];
        let i = 0;
        return new Readable({
            ...opts,
            read (cb) {
                this.push(i === data.length ? null : data[i++]);
                cb(null);
            }
        });
    }
    static isBackpressured(rs) {
        return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark;
    }
    static isPaused(rs) {
        return (rs._duplexState & READ_RESUMED) === 0;
    }
    [asyncIterator]() {
        const stream = this;
        let error = null;
        let promiseResolve = null;
        let promiseReject = null;
        this.on('error', (err)=>{
            error = err;
        });
        this.on('readable', onreadable);
        this.on('close', onclose);
        return {
            [asyncIterator] () {
                return this;
            },
            next () {
                return new Promise(function(resolve, reject) {
                    promiseResolve = resolve;
                    promiseReject = reject;
                    const data = stream.read();
                    if (data !== null) ondata(data);
                    else if ((stream._duplexState & DESTROYED) !== 0) ondata(null);
                });
            },
            return () {
                return destroy(null);
            },
            throw (err) {
                return destroy(err);
            }
        };
        //TURBOPACK unreachable
        ;
        function onreadable() {
            if (promiseResolve !== null) ondata(stream.read());
        }
        function onclose() {
            if (promiseResolve !== null) ondata(null);
        }
        function ondata(data) {
            if (promiseReject === null) return;
            if (error) promiseReject(error);
            else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED);
            else promiseResolve({
                value: data,
                done: data === null
            });
            promiseReject = promiseResolve = null;
        }
        function destroy(err) {
            stream.destroy(err);
            return new Promise((resolve, reject)=>{
                if (stream._duplexState & DESTROYED) return resolve({
                    value: undefined,
                    done: true
                });
                stream.once('close', function() {
                    if (err) reject(err);
                    else resolve({
                        value: undefined,
                        done: true
                    });
                });
            });
        }
    }
}
class Writable extends Stream {
    constructor(opts){
        super(opts);
        this._duplexState |= OPENING | READ_DONE;
        this._writableState = new WritableState(this, opts);
        if (opts) {
            if (opts.writev) this._writev = opts.writev;
            if (opts.write) this._write = opts.write;
            if (opts.final) this._final = opts.final;
            if (opts.eagerOpen) this._writableState.updateNextTick();
        }
    }
    cork() {
        this._duplexState |= WRITE_CORKED;
    }
    uncork() {
        this._duplexState &= WRITE_NOT_CORKED;
        this._writableState.updateNextTick();
    }
    _writev(batch, cb) {
        cb(null);
    }
    _write(data, cb) {
        this._writableState.autoBatch(data, cb);
    }
    _final(cb) {
        cb(null);
    }
    static isBackpressured(ws) {
        return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0;
    }
    static drained(ws) {
        if (ws.destroyed) return Promise.resolve(false);
        const state = ws._writableState;
        const pending = isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length;
        const writes = pending + (ws._duplexState & WRITE_WRITING ? 1 : 0);
        if (writes === 0) return Promise.resolve(true);
        if (state.drains === null) state.drains = [];
        return new Promise((resolve)=>{
            state.drains.push({
                writes,
                resolve
            });
        });
    }
    write(data) {
        this._writableState.updateNextTick();
        return this._writableState.push(data);
    }
    end(data) {
        this._writableState.updateNextTick();
        this._writableState.end(data);
        return this;
    }
}
class Duplex extends Readable {
    constructor(opts){
        super(opts);
        this._duplexState = OPENING | this._duplexState & READ_READ_AHEAD;
        this._writableState = new WritableState(this, opts);
        if (opts) {
            if (opts.writev) this._writev = opts.writev;
            if (opts.write) this._write = opts.write;
            if (opts.final) this._final = opts.final;
        }
    }
    cork() {
        this._duplexState |= WRITE_CORKED;
    }
    uncork() {
        this._duplexState &= WRITE_NOT_CORKED;
        this._writableState.updateNextTick();
    }
    _writev(batch, cb) {
        cb(null);
    }
    _write(data, cb) {
        this._writableState.autoBatch(data, cb);
    }
    _final(cb) {
        cb(null);
    }
    write(data) {
        this._writableState.updateNextTick();
        return this._writableState.push(data);
    }
    end(data) {
        this._writableState.updateNextTick();
        this._writableState.end(data);
        return this;
    }
}
class Transform extends Duplex {
    constructor(opts){
        super(opts);
        this._transformState = new TransformState(this);
        if (opts) {
            if (opts.transform) this._transform = opts.transform;
            if (opts.flush) this._flush = opts.flush;
        }
    }
    _write(data, cb) {
        if (this._readableState.buffered >= this._readableState.highWaterMark) {
            this._transformState.data = data;
        } else {
            this._transform(data, this._transformState.afterTransform);
        }
    }
    _read(cb) {
        if (this._transformState.data !== null) {
            const data = this._transformState.data;
            this._transformState.data = null;
            cb(null);
            this._transform(data, this._transformState.afterTransform);
        } else {
            cb(null);
        }
    }
    destroy(err) {
        super.destroy(err);
        if (this._transformState.data !== null) {
            this._transformState.data = null;
            this._transformState.afterTransform();
        }
    }
    _transform(data, cb) {
        cb(null, data);
    }
    _flush(cb) {
        cb(null);
    }
    _final(cb) {
        this._transformState.afterFinal = cb;
        this._flush(transformAfterFlush.bind(this));
    }
}
class PassThrough extends Transform {
}
function transformAfterFlush(err, data) {
    const cb = this._transformState.afterFinal;
    if (err) return cb(err);
    if (data !== null && data !== undefined) this.push(data);
    this.push(null);
    cb(null);
}
function pipelinePromise(...streams) {
    return new Promise((resolve, reject)=>{
        return pipeline(...streams, (err)=>{
            if (err) return reject(err);
            resolve();
        });
    });
}
function pipeline(stream, ...streams) {
    const all = Array.isArray(stream) ? [
        ...stream,
        ...streams
    ] : [
        stream,
        ...streams
    ];
    const done = all.length && typeof all[all.length - 1] === 'function' ? all.pop() : null;
    if (all.length < 2) throw new Error('Pipeline requires at least 2 streams');
    let src = all[0];
    let dest = null;
    let error = null;
    for(let i = 1; i < all.length; i++){
        dest = all[i];
        if (isStreamx(src)) {
            src.pipe(dest, onerror);
        } else {
            errorHandle(src, true, i > 1, onerror);
            src.pipe(dest);
        }
        src = dest;
    }
    if (done) {
        let fin = false;
        const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy);
        dest.on('error', (err)=>{
            if (error === null) error = err;
        });
        dest.on('finish', ()=>{
            fin = true;
            if (!autoDestroy) done(error);
        });
        if (autoDestroy) {
            dest.on('close', ()=>done(error || (fin ? null : PREMATURE_CLOSE)));
        }
    }
    return dest;
    //TURBOPACK unreachable
    ;
    function errorHandle(s, rd, wr, onerror) {
        s.on('error', onerror);
        s.on('close', onclose);
        function onclose() {
            if (rd && s._readableState && !s._readableState.ended) return onerror(PREMATURE_CLOSE);
            if (wr && s._writableState && !s._writableState.ended) return onerror(PREMATURE_CLOSE);
        }
    }
    function onerror(err) {
        if (!err || error) return;
        error = err;
        for (const s of all){
            s.destroy(err);
        }
    }
}
function echo(s) {
    return s;
}
function isStream(stream) {
    return !!stream._readableState || !!stream._writableState;
}
function isStreamx(stream) {
    return typeof stream._duplexState === 'number' && isStream(stream);
}
function isEnded(stream) {
    return !!stream._readableState && stream._readableState.ended;
}
function isFinished(stream) {
    return !!stream._writableState && stream._writableState.ended;
}
function getStreamError(stream, opts = {}) {
    const err = stream._readableState && stream._readableState.error || stream._writableState && stream._writableState.error;
    // avoid implicit errors by default
    return !opts.all && err === STREAM_DESTROYED ? null : err;
}
function isReadStreamx(stream) {
    return isStreamx(stream) && stream.readable;
}
function isDisturbed(stream) {
    return (stream._duplexState & OPENING) !== OPENING || (stream._duplexState & ACTIVE_OR_TICKING) !== 0;
}
function isTypedArray(data) {
    return typeof data === 'object' && data !== null && typeof data.byteLength === 'number';
}
function defaultByteLength(data) {
    return isTypedArray(data) ? data.byteLength : 1024;
}
function noop() {}
function abort() {
    this.destroy(new Error('Stream aborted.'));
}
function isWritev(s) {
    return s._writev !== Writable.prototype._writev && s._writev !== Duplex.prototype._writev;
}
module.exports = {
    pipeline,
    pipelinePromise,
    isStream,
    isStreamx,
    isEnded,
    isFinished,
    isDisturbed,
    getStreamError,
    Stream,
    Writable,
    Readable,
    Duplex,
    Transform,
    // Export PassThrough for compatibility with Node.js core's stream module
    PassThrough
};
}),
"[project]/node_modules/.pnpm/tar-stream@3.1.7/node_modules/tar-stream/headers.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

const b4a = __turbopack_context__.r("[project]/node_modules/.pnpm/b4a@1.7.3/node_modules/b4a/index.js [app-rsc] (ecmascript)");
const ZEROS = '0000000000000000000';
const SEVENS = '7777777777777777777';
const ZERO_OFFSET = '0'.charCodeAt(0);
const USTAR_MAGIC = b4a.from([
    0x75,
    0x73,
    0x74,
    0x61,
    0x72,
    0x00
]) // ustar\x00
;
const USTAR_VER = b4a.from([
    ZERO_OFFSET,
    ZERO_OFFSET
]);
const GNU_MAGIC = b4a.from([
    0x75,
    0x73,
    0x74,
    0x61,
    0x72,
    0x20
]) // ustar\x20
;
const GNU_VER = b4a.from([
    0x20,
    0x00
]);
const MASK = 0o7777;
const MAGIC_OFFSET = 257;
const VERSION_OFFSET = 263;
exports.decodeLongPath = function decodeLongPath(buf, encoding) {
    return decodeStr(buf, 0, buf.length, encoding);
};
exports.encodePax = function encodePax(opts) {
    let result = '';
    if (opts.name) result += addLength(' path=' + opts.name + '\n');
    if (opts.linkname) result += addLength(' linkpath=' + opts.linkname + '\n');
    const pax = opts.pax;
    if (pax) {
        for(const key in pax){
            result += addLength(' ' + key + '=' + pax[key] + '\n');
        }
    }
    return b4a.from(result);
};
exports.decodePax = function decodePax(buf) {
    const result = {};
    while(buf.length){
        let i = 0;
        while(i < buf.length && buf[i] !== 32)i++;
        const len = parseInt(b4a.toString(buf.subarray(0, i)), 10);
        if (!len) return result;
        const b = b4a.toString(buf.subarray(i + 1, len - 1));
        const keyIndex = b.indexOf('=');
        if (keyIndex === -1) return result;
        result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
        buf = buf.subarray(len);
    }
    return result;
};
exports.encode = function encode(opts) {
    const buf = b4a.alloc(512);
    let name = opts.name;
    let prefix = '';
    if (opts.typeflag === 5 && name[name.length - 1] !== '/') name += '/';
    if (b4a.byteLength(name) !== name.length) return null // utf-8
    ;
    while(b4a.byteLength(name) > 100){
        const i = name.indexOf('/');
        if (i === -1) return null;
        prefix += prefix ? '/' + name.slice(0, i) : name.slice(0, i);
        name = name.slice(i + 1);
    }
    if (b4a.byteLength(name) > 100 || b4a.byteLength(prefix) > 155) return null;
    if (opts.linkname && b4a.byteLength(opts.linkname) > 100) return null;
    b4a.write(buf, name);
    b4a.write(buf, encodeOct(opts.mode & MASK, 6), 100);
    b4a.write(buf, encodeOct(opts.uid, 6), 108);
    b4a.write(buf, encodeOct(opts.gid, 6), 116);
    encodeSize(opts.size, buf, 124);
    b4a.write(buf, encodeOct(opts.mtime.getTime() / 1000 | 0, 11), 136);
    buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
    if (opts.linkname) b4a.write(buf, opts.linkname, 157);
    b4a.copy(USTAR_MAGIC, buf, MAGIC_OFFSET);
    b4a.copy(USTAR_VER, buf, VERSION_OFFSET);
    if (opts.uname) b4a.write(buf, opts.uname, 265);
    if (opts.gname) b4a.write(buf, opts.gname, 297);
    b4a.write(buf, encodeOct(opts.devmajor || 0, 6), 329);
    b4a.write(buf, encodeOct(opts.devminor || 0, 6), 337);
    if (prefix) b4a.write(buf, prefix, 345);
    b4a.write(buf, encodeOct(cksum(buf), 6), 148);
    return buf;
};
exports.decode = function decode(buf, filenameEncoding, allowUnknownFormat) {
    let typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
    let name = decodeStr(buf, 0, 100, filenameEncoding);
    const mode = decodeOct(buf, 100, 8);
    const uid = decodeOct(buf, 108, 8);
    const gid = decodeOct(buf, 116, 8);
    const size = decodeOct(buf, 124, 12);
    const mtime = decodeOct(buf, 136, 12);
    const type = toType(typeflag);
    const linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
    const uname = decodeStr(buf, 265, 32);
    const gname = decodeStr(buf, 297, 32);
    const devmajor = decodeOct(buf, 329, 8);
    const devminor = decodeOct(buf, 337, 8);
    const c = cksum(buf);
    // checksum is still initial value if header was null.
    if (c === 8 * 32) return null;
    // valid checksum
    if (c !== decodeOct(buf, 148, 8)) throw new Error('Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?');
    if (isUSTAR(buf)) {
        // ustar (posix) format.
        // prepend prefix, if present.
        if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + '/' + name;
    } else if (isGNU(buf)) {
    // 'gnu'/'oldgnu' format. Similar to ustar, but has support for incremental and
    // multi-volume tarballs.
    } else {
        if (!allowUnknownFormat) {
            throw new Error('Invalid tar header: unknown format.');
        }
    }
    // to support old tar versions that use trailing / to indicate dirs
    if (typeflag === 0 && name && name[name.length - 1] === '/') typeflag = 5;
    return {
        name,
        mode,
        uid,
        gid,
        size,
        mtime: new Date(1000 * mtime),
        type,
        linkname,
        uname,
        gname,
        devmajor,
        devminor,
        pax: null
    };
};
function isUSTAR(buf) {
    return b4a.equals(USTAR_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6));
}
function isGNU(buf) {
    return b4a.equals(GNU_MAGIC, buf.subarray(MAGIC_OFFSET, MAGIC_OFFSET + 6)) && b4a.equals(GNU_VER, buf.subarray(VERSION_OFFSET, VERSION_OFFSET + 2));
}
function clamp(index, len, defaultValue) {
    if (typeof index !== 'number') return defaultValue;
    index = ~~index; // Coerce to integer.
    if (index >= len) return len;
    if (index >= 0) return index;
    index += len;
    if (index >= 0) return index;
    return 0;
}
function toType(flag) {
    switch(flag){
        case 0:
            return 'file';
        case 1:
            return 'link';
        case 2:
            return 'symlink';
        case 3:
            return 'character-device';
        case 4:
            return 'block-device';
        case 5:
            return 'directory';
        case 6:
            return 'fifo';
        case 7:
            return 'contiguous-file';
        case 72:
            return 'pax-header';
        case 55:
            return 'pax-global-header';
        case 27:
            return 'gnu-long-link-path';
        case 28:
        case 30:
            return 'gnu-long-path';
    }
    return null;
}
function toTypeflag(flag) {
    switch(flag){
        case 'file':
            return 0;
        case 'link':
            return 1;
        case 'symlink':
            return 2;
        case 'character-device':
            return 3;
        case 'block-device':
            return 4;
        case 'directory':
            return 5;
        case 'fifo':
            return 6;
        case 'contiguous-file':
            return 7;
        case 'pax-header':
            return 72;
    }
    return 0;
}
function indexOf(block, num, offset, end) {
    for(; offset < end; offset++){
        if (block[offset] === num) return offset;
    }
    return end;
}
function cksum(block) {
    let sum = 8 * 32;
    for(let i = 0; i < 148; i++)sum += block[i];
    for(let j = 156; j < 512; j++)sum += block[j];
    return sum;
}
function encodeOct(val, n) {
    val = val.toString(8);
    if (val.length > n) return SEVENS.slice(0, n) + ' ';
    return ZEROS.slice(0, n - val.length) + val + ' ';
}
function encodeSizeBin(num, buf, off) {
    buf[off] = 0x80;
    for(let i = 11; i > 0; i--){
        buf[off + i] = num & 0xff;
        num = Math.floor(num / 0x100);
    }
}
function encodeSize(num, buf, off) {
    if (num.toString(8).length > 11) {
        encodeSizeBin(num, buf, off);
    } else {
        b4a.write(buf, encodeOct(num, 11), off);
    }
}
/* Copied from the node-tar repo and modified to meet
 * tar-stream coding standard.
 *
 * Source: https://github.com/npm/node-tar/blob/51b6627a1f357d2eb433e7378e5f05e83b7aa6cd/lib/header.js#L349
 */ function parse256(buf) {
    // first byte MUST be either 80 or FF
    // 80 for positive, FF for 2's comp
    let positive;
    if (buf[0] === 0x80) positive = true;
    else if (buf[0] === 0xFF) positive = false;
    else return null;
    // build up a base-256 tuple from the least sig to the highest
    const tuple = [];
    let i;
    for(i = buf.length - 1; i > 0; i--){
        const byte = buf[i];
        if (positive) tuple.push(byte);
        else tuple.push(0xFF - byte);
    }
    let sum = 0;
    const l = tuple.length;
    for(i = 0; i < l; i++){
        sum += tuple[i] * Math.pow(256, i);
    }
    return positive ? sum : -1 * sum;
}
function decodeOct(val, offset, length) {
    val = val.subarray(offset, offset + length);
    offset = 0;
    // If prefixed with 0x80 then parse as a base-256 integer
    if (val[offset] & 0x80) {
        return parse256(val);
    } else {
        // Older versions of tar can prefix with spaces
        while(offset < val.length && val[offset] === 32)offset++;
        const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
        while(offset < end && val[offset] === 0)offset++;
        if (end === offset) return 0;
        return parseInt(b4a.toString(val.subarray(offset, end)), 8);
    }
}
function decodeStr(val, offset, length, encoding) {
    return b4a.toString(val.subarray(offset, indexOf(val, 0, offset, offset + length)), encoding);
}
function addLength(str) {
    const len = b4a.byteLength(str);
    let digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
    if (len + digits >= Math.pow(10, digits)) digits++;
    return len + digits + str;
}
}),
"[project]/node_modules/.pnpm/tar-stream@3.1.7/node_modules/tar-stream/extract.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

const { Writable, Readable, getStreamError } = __turbopack_context__.r("[project]/node_modules/.pnpm/streamx@2.23.0/node_modules/streamx/index.js [app-rsc] (ecmascript)");
const FIFO = __turbopack_context__.r("[project]/node_modules/.pnpm/fast-fifo@1.3.2/node_modules/fast-fifo/index.js [app-rsc] (ecmascript)");
const b4a = __turbopack_context__.r("[project]/node_modules/.pnpm/b4a@1.7.3/node_modules/b4a/index.js [app-rsc] (ecmascript)");
const headers = __turbopack_context__.r("[project]/node_modules/.pnpm/tar-stream@3.1.7/node_modules/tar-stream/headers.js [app-rsc] (ecmascript)");
const EMPTY = b4a.alloc(0);
class BufferList {
    constructor(){
        this.buffered = 0;
        this.shifted = 0;
        this.queue = new FIFO();
        this._offset = 0;
    }
    push(buffer) {
        this.buffered += buffer.byteLength;
        this.queue.push(buffer);
    }
    shiftFirst(size) {
        return this._buffered === 0 ? null : this._next(size);
    }
    shift(size) {
        if (size > this.buffered) return null;
        if (size === 0) return EMPTY;
        let chunk = this._next(size);
        if (size === chunk.byteLength) return chunk // likely case
        ;
        const chunks = [
            chunk
        ];
        while((size -= chunk.byteLength) > 0){
            chunk = this._next(size);
            chunks.push(chunk);
        }
        return b4a.concat(chunks);
    }
    _next(size) {
        const buf = this.queue.peek();
        const rem = buf.byteLength - this._offset;
        if (size >= rem) {
            const sub = this._offset ? buf.subarray(this._offset, buf.byteLength) : buf;
            this.queue.shift();
            this._offset = 0;
            this.buffered -= rem;
            this.shifted += rem;
            return sub;
        }
        this.buffered -= size;
        this.shifted += size;
        return buf.subarray(this._offset, this._offset += size);
    }
}
class Source extends Readable {
    constructor(self, header, offset){
        super();
        this.header = header;
        this.offset = offset;
        this._parent = self;
    }
    _read(cb) {
        if (this.header.size === 0) {
            this.push(null);
        }
        if (this._parent._stream === this) {
            this._parent._update();
        }
        cb(null);
    }
    _predestroy() {
        this._parent.destroy(getStreamError(this));
    }
    _detach() {
        if (this._parent._stream === this) {
            this._parent._stream = null;
            this._parent._missing = overflow(this.header.size);
            this._parent._update();
        }
    }
    _destroy(cb) {
        this._detach();
        cb(null);
    }
}
class Extract extends Writable {
    constructor(opts){
        super(opts);
        if (!opts) opts = {};
        this._buffer = new BufferList();
        this._offset = 0;
        this._header = null;
        this._stream = null;
        this._missing = 0;
        this._longHeader = false;
        this._callback = noop;
        this._locked = false;
        this._finished = false;
        this._pax = null;
        this._paxGlobal = null;
        this._gnuLongPath = null;
        this._gnuLongLinkPath = null;
        this._filenameEncoding = opts.filenameEncoding || 'utf-8';
        this._allowUnknownFormat = !!opts.allowUnknownFormat;
        this._unlockBound = this._unlock.bind(this);
    }
    _unlock(err) {
        this._locked = false;
        if (err) {
            this.destroy(err);
            this._continueWrite(err);
            return;
        }
        this._update();
    }
    _consumeHeader() {
        if (this._locked) return false;
        this._offset = this._buffer.shifted;
        try {
            this._header = headers.decode(this._buffer.shift(512), this._filenameEncoding, this._allowUnknownFormat);
        } catch (err) {
            this._continueWrite(err);
            return false;
        }
        if (!this._header) return true;
        switch(this._header.type){
            case 'gnu-long-path':
            case 'gnu-long-link-path':
            case 'pax-global-header':
            case 'pax-header':
                this._longHeader = true;
                this._missing = this._header.size;
                return true;
        }
        this._locked = true;
        this._applyLongHeaders();
        if (this._header.size === 0 || this._header.type === 'directory') {
            this.emit('entry', this._header, this._createStream(), this._unlockBound);
            return true;
        }
        this._stream = this._createStream();
        this._missing = this._header.size;
        this.emit('entry', this._header, this._stream, this._unlockBound);
        return true;
    }
    _applyLongHeaders() {
        if (this._gnuLongPath) {
            this._header.name = this._gnuLongPath;
            this._gnuLongPath = null;
        }
        if (this._gnuLongLinkPath) {
            this._header.linkname = this._gnuLongLinkPath;
            this._gnuLongLinkPath = null;
        }
        if (this._pax) {
            if (this._pax.path) this._header.name = this._pax.path;
            if (this._pax.linkpath) this._header.linkname = this._pax.linkpath;
            if (this._pax.size) this._header.size = parseInt(this._pax.size, 10);
            this._header.pax = this._pax;
            this._pax = null;
        }
    }
    _decodeLongHeader(buf) {
        switch(this._header.type){
            case 'gnu-long-path':
                this._gnuLongPath = headers.decodeLongPath(buf, this._filenameEncoding);
                break;
            case 'gnu-long-link-path':
                this._gnuLongLinkPath = headers.decodeLongPath(buf, this._filenameEncoding);
                break;
            case 'pax-global-header':
                this._paxGlobal = headers.decodePax(buf);
                break;
            case 'pax-header':
                this._pax = this._paxGlobal === null ? headers.decodePax(buf) : Object.assign({}, this._paxGlobal, headers.decodePax(buf));
                break;
        }
    }
    _consumeLongHeader() {
        this._longHeader = false;
        this._missing = overflow(this._header.size);
        const buf = this._buffer.shift(this._header.size);
        try {
            this._decodeLongHeader(buf);
        } catch (err) {
            this._continueWrite(err);
            return false;
        }
        return true;
    }
    _consumeStream() {
        const buf = this._buffer.shiftFirst(this._missing);
        if (buf === null) return false;
        this._missing -= buf.byteLength;
        const drained = this._stream.push(buf);
        if (this._missing === 0) {
            this._stream.push(null);
            if (drained) this._stream._detach();
            return drained && this._locked === false;
        }
        return drained;
    }
    _createStream() {
        return new Source(this, this._header, this._offset);
    }
    _update() {
        while(this._buffer.buffered > 0 && !this.destroying){
            if (this._missing > 0) {
                if (this._stream !== null) {
                    if (this._consumeStream() === false) return;
                    continue;
                }
                if (this._longHeader === true) {
                    if (this._missing > this._buffer.buffered) break;
                    if (this._consumeLongHeader() === false) return false;
                    continue;
                }
                const ignore = this._buffer.shiftFirst(this._missing);
                if (ignore !== null) this._missing -= ignore.byteLength;
                continue;
            }
            if (this._buffer.buffered < 512) break;
            if (this._stream !== null || this._consumeHeader() === false) return;
        }
        this._continueWrite(null);
    }
    _continueWrite(err) {
        const cb = this._callback;
        this._callback = noop;
        cb(err);
    }
    _write(data, cb) {
        this._callback = cb;
        this._buffer.push(data);
        this._update();
    }
    _final(cb) {
        this._finished = this._missing === 0 && this._buffer.buffered === 0;
        cb(this._finished ? null : new Error('Unexpected end of data'));
    }
    _predestroy() {
        this._continueWrite(null);
    }
    _destroy(cb) {
        if (this._stream) this._stream.destroy(getStreamError(this));
        cb(null);
    }
    [Symbol.asyncIterator]() {
        let error = null;
        let promiseResolve = null;
        let promiseReject = null;
        let entryStream = null;
        let entryCallback = null;
        const extract = this;
        this.on('entry', onentry);
        this.on('error', (err)=>{
            error = err;
        });
        this.on('close', onclose);
        return {
            [Symbol.asyncIterator] () {
                return this;
            },
            next () {
                return new Promise(onnext);
            },
            return () {
                return destroy(null);
            },
            throw (err) {
                return destroy(err);
            }
        };
        //TURBOPACK unreachable
        ;
        function consumeCallback(err) {
            if (!entryCallback) return;
            const cb = entryCallback;
            entryCallback = null;
            cb(err);
        }
        function onnext(resolve, reject) {
            if (error) {
                return reject(error);
            }
            if (entryStream) {
                resolve({
                    value: entryStream,
                    done: false
                });
                entryStream = null;
                return;
            }
            promiseResolve = resolve;
            promiseReject = reject;
            consumeCallback(null);
            if (extract._finished && promiseResolve) {
                promiseResolve({
                    value: undefined,
                    done: true
                });
                promiseResolve = promiseReject = null;
            }
        }
        function onentry(header, stream, callback) {
            entryCallback = callback;
            stream.on('error', noop); // no way around this due to tick sillyness
            if (promiseResolve) {
                promiseResolve({
                    value: stream,
                    done: false
                });
                promiseResolve = promiseReject = null;
            } else {
                entryStream = stream;
            }
        }
        function onclose() {
            consumeCallback(error);
            if (!promiseResolve) return;
            if (error) promiseReject(error);
            else promiseResolve({
                value: undefined,
                done: true
            });
            promiseResolve = promiseReject = null;
        }
        function destroy(err) {
            extract.destroy(err);
            consumeCallback(err);
            return new Promise((resolve, reject)=>{
                if (extract.destroyed) return resolve({
                    value: undefined,
                    done: true
                });
                extract.once('close', function() {
                    if (err) reject(err);
                    else resolve({
                        value: undefined,
                        done: true
                    });
                });
            });
        }
    }
}
module.exports = function extract(opts) {
    return new Extract(opts);
};
function noop() {}
function overflow(size) {
    size &= 511;
    return size && 512 - size;
}
}),
"[project]/node_modules/.pnpm/tar-stream@3.1.7/node_modules/tar-stream/constants.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

const constants = {
    S_IFMT: 61440,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960
};
try {
    module.exports = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)").constants || constants;
} catch  {
    module.exports = constants;
}
}),
"[project]/node_modules/.pnpm/tar-stream@3.1.7/node_modules/tar-stream/pack.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

const { Readable, Writable, getStreamError } = __turbopack_context__.r("[project]/node_modules/.pnpm/streamx@2.23.0/node_modules/streamx/index.js [app-rsc] (ecmascript)");
const b4a = __turbopack_context__.r("[project]/node_modules/.pnpm/b4a@1.7.3/node_modules/b4a/index.js [app-rsc] (ecmascript)");
const constants = __turbopack_context__.r("[project]/node_modules/.pnpm/tar-stream@3.1.7/node_modules/tar-stream/constants.js [app-rsc] (ecmascript)");
const headers = __turbopack_context__.r("[project]/node_modules/.pnpm/tar-stream@3.1.7/node_modules/tar-stream/headers.js [app-rsc] (ecmascript)");
const DMODE = 0o755;
const FMODE = 0o644;
const END_OF_TAR = b4a.alloc(1024);
class Sink extends Writable {
    constructor(pack, header, callback){
        super({
            mapWritable,
            eagerOpen: true
        });
        this.written = 0;
        this.header = header;
        this._callback = callback;
        this._linkname = null;
        this._isLinkname = header.type === 'symlink' && !header.linkname;
        this._isVoid = header.type !== 'file' && header.type !== 'contiguous-file';
        this._finished = false;
        this._pack = pack;
        this._openCallback = null;
        if (this._pack._stream === null) this._pack._stream = this;
        else this._pack._pending.push(this);
    }
    _open(cb) {
        this._openCallback = cb;
        if (this._pack._stream === this) this._continueOpen();
    }
    _continuePack(err) {
        if (this._callback === null) return;
        const callback = this._callback;
        this._callback = null;
        callback(err);
    }
    _continueOpen() {
        if (this._pack._stream === null) this._pack._stream = this;
        const cb = this._openCallback;
        this._openCallback = null;
        if (cb === null) return;
        if (this._pack.destroying) return cb(new Error('pack stream destroyed'));
        if (this._pack._finalized) return cb(new Error('pack stream is already finalized'));
        this._pack._stream = this;
        if (!this._isLinkname) {
            this._pack._encode(this.header);
        }
        if (this._isVoid) {
            this._finish();
            this._continuePack(null);
        }
        cb(null);
    }
    _write(data, cb) {
        if (this._isLinkname) {
            this._linkname = this._linkname ? b4a.concat([
                this._linkname,
                data
            ]) : data;
            return cb(null);
        }
        if (this._isVoid) {
            if (data.byteLength > 0) {
                return cb(new Error('No body allowed for this entry'));
            }
            return cb();
        }
        this.written += data.byteLength;
        if (this._pack.push(data)) return cb();
        this._pack._drain = cb;
    }
    _finish() {
        if (this._finished) return;
        this._finished = true;
        if (this._isLinkname) {
            this.header.linkname = this._linkname ? b4a.toString(this._linkname, 'utf-8') : '';
            this._pack._encode(this.header);
        }
        overflow(this._pack, this.header.size);
        this._pack._done(this);
    }
    _final(cb) {
        if (this.written !== this.header.size) {
            return cb(new Error('Size mismatch'));
        }
        this._finish();
        cb(null);
    }
    _getError() {
        return getStreamError(this) || new Error('tar entry destroyed');
    }
    _predestroy() {
        this._pack.destroy(this._getError());
    }
    _destroy(cb) {
        this._pack._done(this);
        this._continuePack(this._finished ? null : this._getError());
        cb();
    }
}
class Pack extends Readable {
    constructor(opts){
        super(opts);
        this._drain = noop;
        this._finalized = false;
        this._finalizing = false;
        this._pending = [];
        this._stream = null;
    }
    entry(header, buffer, callback) {
        if (this._finalized || this.destroying) throw new Error('already finalized or destroyed');
        if (typeof buffer === 'function') {
            callback = buffer;
            buffer = null;
        }
        if (!callback) callback = noop;
        if (!header.size || header.type === 'symlink') header.size = 0;
        if (!header.type) header.type = modeToType(header.mode);
        if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE;
        if (!header.uid) header.uid = 0;
        if (!header.gid) header.gid = 0;
        if (!header.mtime) header.mtime = new Date();
        if (typeof buffer === 'string') buffer = b4a.from(buffer);
        const sink = new Sink(this, header, callback);
        if (b4a.isBuffer(buffer)) {
            header.size = buffer.byteLength;
            sink.write(buffer);
            sink.end();
            return sink;
        }
        if (sink._isVoid) {
            return sink;
        }
        return sink;
    }
    finalize() {
        if (this._stream || this._pending.length > 0) {
            this._finalizing = true;
            return;
        }
        if (this._finalized) return;
        this._finalized = true;
        this.push(END_OF_TAR);
        this.push(null);
    }
    _done(stream) {
        if (stream !== this._stream) return;
        this._stream = null;
        if (this._finalizing) this.finalize();
        if (this._pending.length) this._pending.shift()._continueOpen();
    }
    _encode(header) {
        if (!header.pax) {
            const buf = headers.encode(header);
            if (buf) {
                this.push(buf);
                return;
            }
        }
        this._encodePax(header);
    }
    _encodePax(header) {
        const paxHeader = headers.encodePax({
            name: header.name,
            linkname: header.linkname,
            pax: header.pax
        });
        const newHeader = {
            name: 'PaxHeader',
            mode: header.mode,
            uid: header.uid,
            gid: header.gid,
            size: paxHeader.byteLength,
            mtime: header.mtime,
            type: 'pax-header',
            linkname: header.linkname && 'PaxHeader',
            uname: header.uname,
            gname: header.gname,
            devmajor: header.devmajor,
            devminor: header.devminor
        };
        this.push(headers.encode(newHeader));
        this.push(paxHeader);
        overflow(this, paxHeader.byteLength);
        newHeader.size = header.size;
        newHeader.type = header.type;
        this.push(headers.encode(newHeader));
    }
    _doDrain() {
        const drain = this._drain;
        this._drain = noop;
        drain();
    }
    _predestroy() {
        const err = getStreamError(this);
        if (this._stream) this._stream.destroy(err);
        while(this._pending.length){
            const stream = this._pending.shift();
            stream.destroy(err);
            stream._continueOpen();
        }
        this._doDrain();
    }
    _read(cb) {
        this._doDrain();
        cb();
    }
}
module.exports = function pack(opts) {
    return new Pack(opts);
};
function modeToType(mode) {
    switch(mode & constants.S_IFMT){
        case constants.S_IFBLK:
            return 'block-device';
        case constants.S_IFCHR:
            return 'character-device';
        case constants.S_IFDIR:
            return 'directory';
        case constants.S_IFIFO:
            return 'fifo';
        case constants.S_IFLNK:
            return 'symlink';
    }
    return 'file';
}
function noop() {}
function overflow(self, size) {
    size &= 511;
    if (size) self.push(END_OF_TAR.subarray(0, 512 - size));
}
function mapWritable(buf) {
    return b4a.isBuffer(buf) ? buf : b4a.from(buf);
}
}),
"[project]/node_modules/.pnpm/tar-stream@3.1.7/node_modules/tar-stream/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

exports.extract = __turbopack_context__.r("[project]/node_modules/.pnpm/tar-stream@3.1.7/node_modules/tar-stream/extract.js [app-rsc] (ecmascript)");
exports.pack = __turbopack_context__.r("[project]/node_modules/.pnpm/tar-stream@3.1.7/node_modules/tar-stream/pack.js [app-rsc] (ecmascript)");
}),
"[project]/node_modules/.pnpm/jsonlines@0.1.1/node_modules/jsonlines/lib/parser.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

var Transform = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Transform;
function Parser(options) {
    if (!(this instanceof Parser)) {
        throw new TypeError('Cannot call a class as a function');
    }
    options = options || {};
    Transform.call(this, {
        objectMode: true
    });
    this._memory = '';
    this._emitInvalidLines = options.emitInvalidLines || false;
}
Parser.prototype = Object.create(Transform.prototype);
Parser.prototype._handleLines = function(lines, cb) {
    for(var i = 0; i < lines.length; i++){
        if (lines[i] === '') continue;
        var err = null;
        var json = null;
        try {
            json = JSON.parse(lines[i]);
        } catch (_err) {
            _err.source = lines[i];
            err = _err;
        }
        if (err) {
            if (this._emitInvalidLines) {
                this.emit('invalid-line', err);
            } else {
                return cb(err);
            }
        } else {
            this.push(json);
        }
    }
    cb(null);
};
Parser.prototype._transform = function(chunk, encoding, cb) {
    var lines = (this._memory + chunk.toString()).split('\n');
    this._memory = lines.pop();
    this._handleLines(lines, cb);
};
Parser.prototype._flush = function(cb) {
    if (!this._memory) return cb(null);
    var line = this._memory;
    this._memory = '';
    this._handleLines([
        line
    ], cb);
};
module.exports = Parser;
}),
"[project]/node_modules/.pnpm/jsonlines@0.1.1/node_modules/jsonlines/lib/stringifier.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

var Transform = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Transform;
function Stringifier() {
    if (!(this instanceof Stringifier)) {
        throw new TypeError('Cannot call a class as a function');
    }
    Transform.call(this, {
        objectMode: true
    });
}
Stringifier.prototype = Object.create(Transform.prototype);
Stringifier.prototype._transform = function(data, _, cb) {
    var value;
    try {
        value = JSON.stringify(data);
    } catch (err) {
        err.source = data;
        return cb(err);
    }
    cb(null, value + '\n');
};
module.exports = Stringifier;
}),
"[project]/node_modules/.pnpm/jsonlines@0.1.1/node_modules/jsonlines/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

var Parser = __turbopack_context__.r("[project]/node_modules/.pnpm/jsonlines@0.1.1/node_modules/jsonlines/lib/parser.js [app-rsc] (ecmascript)");
var Stringifier = __turbopack_context__.r("[project]/node_modules/.pnpm/jsonlines@0.1.1/node_modules/jsonlines/lib/stringifier.js [app-rsc] (ecmascript)");
exports.parse = function parse(options) {
    return new Parser(options);
};
exports.stringify = function stringify() {
    return new Stringifier();
};
}),
"[project]/node_modules/.pnpm/@vercel+oidc@2.0.2/node_modules/@vercel/oidc/dist/get-context.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var get_context_exports = {};
__export(get_context_exports, {
    SYMBOL_FOR_REQ_CONTEXT: ()=>SYMBOL_FOR_REQ_CONTEXT,
    getContext: ()=>getContext
});
module.exports = __toCommonJS(get_context_exports);
const SYMBOL_FOR_REQ_CONTEXT = Symbol.for("@vercel/request-context");
function getContext() {
    const fromSymbol = globalThis;
    return fromSymbol[SYMBOL_FOR_REQ_CONTEXT]?.get?.() ?? {};
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    SYMBOL_FOR_REQ_CONTEXT,
    getContext
});
}),
"[project]/node_modules/.pnpm/@vercel+oidc@2.0.2/node_modules/@vercel/oidc/dist/token-error.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var token_error_exports = {};
__export(token_error_exports, {
    VercelOidcTokenError: ()=>VercelOidcTokenError
});
module.exports = __toCommonJS(token_error_exports);
class VercelOidcTokenError extends Error {
    constructor(message, cause){
        super(message);
        this.name = "VercelOidcTokenError";
        this.cause = cause;
    }
    toString() {
        if (this.cause) {
            return `${this.name}: ${this.message}: ${this.cause}`;
        }
        return `${this.name}: ${this.message}`;
    }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    VercelOidcTokenError
});
}),
"[project]/node_modules/.pnpm/@vercel+oidc@2.0.2/node_modules/@vercel/oidc/dist/get-vercel-oidc-token.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var get_vercel_oidc_token_exports = {};
__export(get_vercel_oidc_token_exports, {
    getVercelOidcToken: ()=>getVercelOidcToken,
    getVercelOidcTokenSync: ()=>getVercelOidcTokenSync
});
module.exports = __toCommonJS(get_vercel_oidc_token_exports);
var import_get_context = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+oidc@2.0.2/node_modules/@vercel/oidc/dist/get-context.js [app-rsc] (ecmascript)");
var import_token_error = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+oidc@2.0.2/node_modules/@vercel/oidc/dist/token-error.js [app-rsc] (ecmascript)");
async function getVercelOidcToken() {
    let token = "";
    let err;
    try {
        token = getVercelOidcTokenSync();
    } catch (error) {
        err = error;
    }
    try {
        const [{ getTokenPayload, isExpired }, { refreshToken }] = await Promise.all([
            await __turbopack_context__.A("[project]/node_modules/.pnpm/@vercel+oidc@2.0.2/node_modules/@vercel/oidc/dist/token-util.js [app-rsc] (ecmascript, async loader)"),
            await __turbopack_context__.A("[project]/node_modules/.pnpm/@vercel+oidc@2.0.2/node_modules/@vercel/oidc/dist/token.js [app-rsc] (ecmascript, async loader)")
        ]);
        if (!token || isExpired(getTokenPayload(token))) {
            await refreshToken();
            token = getVercelOidcTokenSync();
        }
    } catch (error) {
        if (err?.message && error instanceof Error) {
            error.message = `${err.message}
${error.message}`;
        }
        throw new import_token_error.VercelOidcTokenError(`Failed to refresh OIDC token`, error);
    }
    return token;
}
function getVercelOidcTokenSync() {
    const token = (0, import_get_context.getContext)().headers?.["x-vercel-oidc-token"] ?? process.env.VERCEL_OIDC_TOKEN;
    if (!token) {
        throw new Error(`The 'x-vercel-oidc-token' header is missing from the request. Do you have the OIDC option enabled in the Vercel project settings?`);
    }
    return token;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    getVercelOidcToken,
    getVercelOidcTokenSync
});
}),
"[project]/node_modules/.pnpm/@vercel+oidc@2.0.2/node_modules/@vercel/oidc/dist/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var src_exports = {};
__export(src_exports, {
    getVercelOidcToken: ()=>import_get_vercel_oidc_token.getVercelOidcToken,
    getVercelOidcTokenSync: ()=>import_get_vercel_oidc_token.getVercelOidcTokenSync
});
module.exports = __toCommonJS(src_exports);
var import_get_vercel_oidc_token = __turbopack_context__.r("[project]/node_modules/.pnpm/@vercel+oidc@2.0.2/node_modules/@vercel/oidc/dist/get-vercel-oidc-token.js [app-rsc] (ecmascript)");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    getVercelOidcToken,
    getVercelOidcTokenSync
});
}),
"[project]/node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js [app-rsc] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Helpers.
 */ var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
        return parse(val);
    } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function parse(str) {
    str = String(str);
    if (str.length > 100) {
        return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
        return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch(type){
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * y;
        case 'weeks':
        case 'week':
        case 'w':
            return n * w;
        case 'days':
        case 'day':
        case 'd':
            return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
        return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
}
/**
 * Pluralization helper.
 */ function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}
}),
"[project]/node_modules/.pnpm/file+..+lib_@vercel+sandbox@0.0.21/node_modules/chrome-sandbox/index.ts [app-rsc] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ChromeSandbox",
    ()=>ChromeSandbox
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$vercel$2b$sandbox$40$0$2e$0$2e$21$2f$node_modules$2f40$vercel$2f$sandbox$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/.pnpm/@vercel+sandbox@0.0.21/node_modules/@vercel/sandbox/dist/index.js [app-rsc] (ecmascript)");
;
class ChromeSandbox extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$vercel$2b$sandbox$40$0$2e$0$2e$21$2f$node_modules$2f40$vercel$2f$sandbox$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Sandbox"] {
    // use outside the sandbox to create a new instance
    static async create(): Promise<ChromeSandbox> {
        const sandbox = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f2e$pnpm$2f40$vercel$2b$sandbox$40$0$2e$0$2e$21$2f$node_modules$2f40$vercel$2f$sandbox$2f$dist$2f$index$2e$js__$5b$app$2d$rsc$5d$__$28$ecmascript$29$__["Sandbox"].create({
            source: {
                type: "git",
                url: "https://github.com/luismeyer/chrome-sandbox"
            }
        });
        // Rebuild as ChromeSandbox with the same params/state
        const chromeSandbox = Object.create(ChromeSandbox.prototype);
        Object.assign(chromeSandbox, sandbox);
        return chromeSandbox;
    }
    private args() {
        const chromiumFlags = [
            "--ash-no-nudges",
            "--disable-domain-reliability",
            "--disable-print-preview",
            "--disk-cache-size=33554432",
            "--no-default-browser-check",
            "--no-pings",
            "--single-process",
            "--font-render-hinting=none"
        ];
        const chromiumDisableFeatures = [
            "AudioServiceOutOfProcess",
            "IsolateOrigins",
            "site-per-process"
        ];
        const chromiumEnableFeatures = [
            "SharedArrayBuffer"
        ];
        const graphicsFlags = [
            "--ignore-gpu-blocklist",
            "--in-process-gpu"
        ];
        graphicsFlags.push("--disable-webgl");
        const insecureFlags = [
            "--allow-running-insecure-content",
            "--disable-setuid-sandbox",
            "--disable-site-isolation-trials",
            "--disable-web-security"
        ];
        const headlessFlags = [
            "--headless='shell'",
            "--no-sandbox",
            "--no-zygote"
        ];
        return [
            ...chromiumFlags,
            `--disable-features=${[
                ...chromiumDisableFeatures
            ].join(",")}`,
            `--enable-features=${[
                ...chromiumEnableFeatures
            ].join(",")}`,
            ...graphicsFlags,
            ...insecureFlags,
            ...headlessFlags
        ];
    }
    async launchBrowser() {
        const installResult = await this.runCommand({
            cmd: "dnf",
            args: [
                "install",
                "-y",
                "chromium"
            ],
            sudo: true
        });
        if (installResult.exitCode !== 0) {
            console.error(installResult.stderr);
            throw new Error("Failed to install chromium");
        }
        console.log(installResult.stdout);
        const launchResult = await this.runCommand({
            cmd: "chromium",
            args: this.args(),
            sudo: true
        });
        if (launchResult.exitCode !== 0) {
            console.error(launchResult.stderr);
            throw new Error("Failed to install chromium");
        }
        console.log(launchResult.stdout);
    }
}
}),
];

//# sourceMappingURL=node_modules__pnpm_191ae8aa._.js.map